%intro.latex
%Introductory document for Neki32 developers
%Bryan E. Topp <betopp@betopp.com> 2024
 
\documentclass[12pt]{article}

\usepackage{geometry}
\usepackage{comment}
\usepackage{courier}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\hypersetup{linktoc=all}

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,linewidth=\textwidth}

%In case we want fancy type like the LaTeX logo
\def\Neki32{{Neki32}}

%For underscores in variable names
\def\Undie{{\_}}

%For lists
\def\BL{{\;} \\ \hspace{1em}{\;}{\textbullet}{\;}\hspace{0.5em}}

%Formatting of memory addresses, registers, etc
\newcommand{\MemAddr}[1]{\texttt{#1}}
\newcommand{\Reg}[1]{\texttt{#1}}
\newcommand{\Const}[1]{\texttt{#1}}
\newcommand{\Instr}[1]{\texttt{#1}}
\newcommand{\CType}[1]{\texttt{#1}}
\newcommand{\VarName}[1]{\texttt{#1}}
\newcommand{\PathName}[1]{\texttt{#1}}

%Formatting of system-call listings
\newcommand{\SysCall}[4]{\subsubsection{\texttt{{\Undie}sc{\Undie}#1}} Called with: \Reg{r0} = \Const{#2}. \\ #3 \begin{itemize} #4 \end{itemize}}
\newcommand{\SysParm}[4]{\item \Reg{#1} : \CType{#2} \VarName{#3}\\ #4 }
\newcommand{\SysRetn}[2]{\item Returns : \CType{#1} \\ #2}
\newcommand{\SysParmNone}[0]{\item No parameters. }
\newcommand{\SysRetnNone}[0]{\item No return value. }
\newcommand{\SysRetnDead}[0]{\item This call does not return. }


\begin{document}

\author{Nekisoft Pty Ltd}
\title{\includegraphics[width=10cm]{logo.png}\\The \Neki32 Software Development Manual}
\date{\today}
\maketitle
\pagebreak

\tableofcontents

\pagebreak

\section*{Preface}

Numbers are in decimal (base-10) unless otherwise stated.\\
Numbers beginning with a \Const{0x} prefix are hexadecimal (base-16).
\\
\\
\copyright2024 Nekisoft Pty Ltd\\
Australian Company Number 680 583 251

\section{Introduction}

Thank you for your interest in developing software for \Neki32!

\subsection{What is \Neki32?}

\Neki32 is a 32-bit game console that delivers a focused experience to both gamers and game developers.
The system runs on an ARM9 CPU clocked at 300MHz. Up to 24MBytes of memory is available for the game process.
Software-rendering is used to produce bitmapped graphics and digital sound.

An operating system hides details of the hardware. Its custom kernel is called ``PVMK'', the Puny Video Machine Kernel.
The system interface is kept to a minimum, to ensure plug-and-play compatibility.

The \Neki32 console itself is powered by USB-C.
It outputs audio and video to an HDMI TV.
Games are distributed on read-only SD cards. 
There are four controller ports, compatible with Genesis and Mega-Drive controllers.
There is 4MBytes of internal memory for savegames of 128KBytes per game.

\begin{center}
\includegraphics[width=13cm]{console.png}

\begin{small}(A real, live Neki32)\end{small}
\end{center}

\pagebreak

\subsection{Technical Specifications}
\begin{itemize}
	\item Power input:
	\begin{itemize}
		\item Connector: USB-C compatible\footnote{The \Neki32 console is not USB\texttrademark{}-certified but should work with any USB-C power supply.}
		\item Voltage: \(5V \pm 10 \% \)
		\item Current: \(\leq 100mA\)
	\end{itemize}
	\item A/V output:
	\begin{itemize}
		\item Connector: HDMI compatible\footnote{It is is also not HDMI\texttrademark{}-certified but should work with any HDMI television.}
		\item Resolution: 640x480, or 320x240 with pixel-doubling
		\item Refresh rate: 60Hz
		\item Aspect ratio: 4:3
		\item Color depth: 16 bits per pixel, RGB565
		\item Audio format: 48KHz 16-bit stereo LPCM
	\end{itemize}
	\item User inputs:
	\begin{itemize}
		\item Connector: 9-pin D-Sub (male) x4
		\item Layout: 8-way directional pad, 6 face buttons, 2 menu buttons
		\item Protocol: Mega-Drive compatible\footnote{Mega-Drive\texttrademark{} is owned by Sega and used without permission. They are unaffiliated with us.}
	\end{itemize}
	\item Game media:
	\begin{itemize}
		\item Connector: SD/MMC card (full-size)
		\item Capacity: 16MBytes to 2TBytes
		\item Format: El-Torito bootable image, platform \Const{0x92}
	\end{itemize}
\end{itemize}

\pagebreak

\subsection{Overview of a Game}

A Neki32 game is quite simple. It is an SD card containing a program to run and possibly other data. Very little is necessary to get code running.

\subsubsection{Game cards}

The card is read-only and formatted much like an optical disc.
It contains an El Torito boot record for platform \Const{0x92}.
The El Torito boot record points at the executable file for the game.

\subsubsection{Executable and environment}

The game executable is a flat, 0-mapped binary image of the game's initial memory content.
For example, if the game executable is 3MBytes in size, the system will load it into virtual memory addresses \MemAddr{0} to \MemAddr{3145727}.
The game process is initially 24 megabytes in size, and the rest will be filled with \Const{0x00} bytes.
The zero page, afterward, is inaccessible. An access of address \MemAddr{0} to \MemAddr{4095} always faults.
On disk, a small magic number is placed at the start of the executable instead (the 8-byte string constant \Const{NNEARM32} and the 8-byte little-endian address \Const{0x1000}).

The game starts execution at address \MemAddr{4096}, the first accessible address.
All registers are zeroed on entry.
The process starts in ARM mode but may switch to Thumb mode at its choice.

System-calls can be made using a \Instr{udf 0x92} instruction.
The call number is placed in \Reg{r0}, while parameters are placed in \Reg{r1} through \Reg{r5}.
Return values are left in \Reg{r0} after the call is performed.
System-calls are nonblocking and can be retried until completion or interleaved with other operations.
System-calls must be made from ARM mode, not Thumb mode.

Processor exceptions caused by game code are fatal. A valid game program should not cause exceptions.
Behind the scenes, exceptions are delivered to the game process as a signal.
However, game processes are not allowed to handle these signals themselves.
The system will stop for debugging or terminate the process, as appropriate.

\subsubsection{Hardware features}

Games can make system-calls to access hardware features.

Images can be displayed from a linear framebuffer, at least 4-byte-aligned, anywhere in the process address space.
The front-buffer can be changed only at the start of vertical blanking.
The kernel will set aside the last requested address and make the flip when vblank starts.
The video scanout loads 16-bit RGB565 pixel data directly from process memory.
Framebuffers should avoid crossing 1MByte address boundaries, for best performance.

Sound can be played using PCM data, at least 4-byte-aligned, anywhere in the process address space.
The kernel sets aside a copy of the data and plays it back using DMA. Only 16-bit 48KHz left-then-right stereo is supported.

Input can be read using a system-call to a buffer, at least 4-byte-aligned, anywhere in the process address space.
Input is retrieved from up to 4 Megadrive-compatible gamepads plugged into the system.
The ports are labelled ``A", ``B", ``C", and ``D".
Input is delivered as a stream of events tagged with these characters as the first byte.

A feature like \VarName{exec()} is available for replacing the running program with another.
The kernel keeps a separate address space ready for a process to load, and then move into place.
Arguments and environment variables can be preserved in a kernel-side buffer during this process.

Nonvolatile memory is available inside the console for savegames.
4MBytes are dedicated to the NVM savegame system, split into records of 128KBytes.
Games are allocated a NVM record, on boot, if their card has a valid Volume ID that doesn't start with \Const{'-'}.
Saving and loading an NVM record are both atomic operations.
The contents of the NVM record is replaced entirely on a successful save.
Interrupted saves do not corrupt the existing record.


\section{The boot process}
The boot process treats the game card like an optical disc - it is read-only and organized in naturally-aligned 2048-byte sectors.
Sector \MemAddr{0} contains bytes \MemAddr{0} to \MemAddr{2047}, sector \MemAddr{1} contains bytes \MemAddr{2048} to \MemAddr{4095}, and so on.

\subsection{The beginning of the media}

The system first reads sectors \Const{0x10} and \Const{0x11}.
Sector \Const{0x10} always contains the ISO9660 Primary Volume Descriptor, describing the game media.
The ISO9660 Primary Volume Descriptor gives the name of the media, in a \Const{32}-byte field at offset \Const{40}.
If this is present, not entirely whitespace, and not \Const{CDROM} or \Const{cdrom}, it is taken to be the game's name.

Savegame memory will be allocated and named automatically according to the name given in the Volume ID of the PVD.
(If the name is not present, or starts with the character \Const{-} (\Const{0x2D}), no savegame memory will be allocated.)

Sector \Const{0x11} always contains the El Torito Boot Volume Descriptor, describing the boot information.
The El Torito Boot Volume Descriptor, from sector \Const{0x11}, is used to locate an El Torito Boot Catalog.
The El Torito Boot Volume Descriptor must contain the magic value \Const{EL TORITO SPECIFICATION} at offset \MemAddr{7}.
It also contains the sector number of the El Torito Boot Catalog, as a 32-bit little-endian number at offset \MemAddr{0x47}.
This is taken to be in units of \Const{2048} bytes, from the beginning of the game media.

\subsection{The boot catalog}
The system reads the El Torito Boot Catalog from the sector number given in the El Torito Boot Volume Descriptor.
Only one sector is read, even though El Torito allows for larger boot catalogs.
The Boot Catalog consists of \Const{32}-byte entries, naturally-aligned.
The first entry must start with the following one-byte magic values:

\begin{tabular}{ r r }
Offset & Value \\
\MemAddr{0x00} & \Const{0x01} \\
\MemAddr{0x1E} & \Const{0x55} \\
\MemAddr{0x1F} & \Const{0xAA}
\end{tabular}

Following this, entries begin with a one-byte value specifying their type, a single byte at offset \MemAddr{0}.

Types \Const{0x01}, \Const{0x90}, or \Const{0x91} begin a section of the Boot Catalog, and contain a Platform ID for entries that follow.
The platform ID is located at offset \MemAddr{1} in such an entry.
The platform ID for a \Neki32 application is \Const{0x92}. A boot entry following this platform will contain game code.
The platform ID for a \Neki32 system-update bundle is \Const{0x22}. A boot entry following this platform will contain packaged system-update data from Nekisoft.

Type \Const{0x88} indicates a bootable entry.
The platform ID of the bootable entry is given in a preceding section entry.
The length of the bootable payload is given as a 2-byte little-endian value at offset \MemAddr{6}. The length is given in units of \Const{512} bytes.
The location of the bootable payload is given as a 4-byte little-endian value at offset \MemAddr{8}. The location is given in units of \Const{2048} bytes, relative to the beginning of the game media.

The first bootable entry of platform ID \Const{0x92} is taken to be the game executable to boot.
The first bootable entry of platform ID \Const{0x22} is taken to be the system update package to examine, if any.
The format of the system update package is not described here.
It should be obtained from Nekisoft and included verbatim.

\subsection{The game executable}

Once the location of the game executable is found in the El Torito Boot Catalog, the system begins to load it.
The game executable is loaded into a new virtual memory space, by itself.
The virtual memory space starts at address \MemAddr{0} and extends to \MemAddr{24M - 1}.
Data is filled to the size specified in the El Torito Boot Catalog. The remaining memory is all \Const{0x00}.
As the size is given as a 16-bit number in units of \Const{512} bytes, up to 32MBytes could be specified.
However, a game on Neki32 is limited to 24MBytes of memory.

After loading, the zero page is checked for an appropriate magic number.
The first eight bytes should be \Const{NNEARM32}.
The second eight bytes should be the entry point as a 64-bit little-endian value.
This value must always be \MemAddr{0x1000}.

Once the game executable is loaded, the game process starts executing it from \MemAddr{0x1000}, with all registers zeroed.

\subsection{Failures}

If any of these steps encounters a missing magic-number or a failure to read the game media, the booting process stops.
Instead of launching the game, the console will drop to its system menu.
The system menu allows users to see the data saved on their console or turn it off.

If the game boots successfully, it should not exit. The user ends the game by turning the console off.
If the game process terminates after being started, the system will try again to launch it, up to 3 times in total.

\section{The instruction set}

The game executable runs in user-mode on an ARMv5TE processor, including both ARM and Thumb modes.
The system will always start executing the game in ARM mode, with the program counter at \MemAddr{0x1000}.
Thumb interworking instructions may be used to transfer into and out of Thumb mode.

No floating-point instructions are available.
Floating-point emulation works well enough to run Quake, at least, if you really want that.

The \Instr{udf 0x92} instruction, encoded as \Const{0xe7f009f2}, is used to trigger system-calls. Other \Instr{udf} instructions should not be used. (If you are curious, we use a \Instr{udf} instruction because GDB ARM refuses to single-step over an \Instr{svc} instruction.) This implies that system-calls must be made from ARM mode, not Thumb mode.

\section{Signals}

The kernel of Neki32, ``PVMK'', provides virtualized handling of processor exceptions.
This means that an illegal memory access or invalid opcode is caught by the operating system.
When this happens, a signal is made pending on that process.

In a game process, all signals are masked, and will not be handled.
When an exception causes a masked signal to become pending, the program cannot continue.
If a debugger is attached, the system will stop for debugging. Otherwise, the process is killed and the game crashes.

\section{Nonvolatile memory system (NVMs)}

The Neki32 console includes memory for savegames.
This allows games to be distributed on common SD cards made read-only, without requiring partially-read-only cards.
Each game can save up to 128KBytes of data. The console has space for 30 such savegames, in a region of 4MBytes of NOR Flash.

To use NVM saving, a game must have a valid title set in the Volume ID of its ISO9660 Primary Volume Descriptor.
The title must be nonempty, not all spaces, and not \Const{CDROM} or \Const{cdrom}.
Additionally, the title must not start with a \Const{-} character.
Games that do not use NVM saving should start their Volume ID with a \Const{-} character.

When the system reads a valid name from the Primary Volume Descriptor, it will set up NVM saving before booting the game.
If insufficient space is available, the user will be warned at that time. They can continue anyway or clean up space.
This all happens before launching the game.

Once the game is running, it may assume that NVM saving is available and working.
Generally, the \VarName{{\Undie}sc{\Undie}nvm{\Undie}save} and \VarName{{\Undie}sc{\Undie}nvm{\Undie}load} calls will not fail.
The game can freely load and store a region of up to 128KBytes.
There is no need to handle no-space-available errors or to prompt the user about making space.
If the user chooses not to make space, a temporary buffer in RAM is accessed by these system-calls instead.

NVM records are protected by SHA256 hashes and double-buffered.
A single free record is always kept for saving the new version of an existing record.
This means that interrupted writes will not corrupt the existing data.
The old version will be used until the new version is written entirely.
There is no need for a game to warn the user about interrupting a save.

The first time a game starts, before any data is saved, it is still valid to call \VarName{{\Undie}sc{\Undie}nvm{\Undie}load}.
The savegame will have been created during the boot process.
A newly allocated savegame will contain 0 bytes when read back.

\section{System calls}

System-calls are used to access hardware features in a backward- and forward-compatible way.
The system-call interface for Neki32 comprises 18 different calls.

To run a system call, first place its inputs in CPU registers. The call number is passed in register \Reg{r0}.
Parameters, if any, are passed in registers \Reg{r1} to \Reg{r5}. Then, use the \Instr{udf 0x92} instruction.
The kernel will perform the requested operation.
The return value is stored in \Reg{r0} after the call finishes.

Typically, system-calls will return a negative error number if they fail, or a nonnegative value on success.
They may read or write in the memory of the caller.

System-calls are nonblocking. If a long-term operation is started, its system-call returns with \Const{-{\Undie}SC{\Undie}EAGAIN}.
The call can be repeated until it completes, returning a successful result.
In the mean time, the \Const{{\Undie}sc{\Undie}pause} system-call can be used to block the caller.
For example, the following code would wait for any input events:
\begin{lstlisting}[language=C]
_sc_input_t mybuf[8] = {0};
while(_sc_input(mybuf, sizeof(mybuf[0]), sizeof(mybuf)) == -_SC_EAGAIN)
{
	_sc_pause();
}
\end{lstlisting}

\subsection{Basics}

These system-calls relate to the general usage of the system-call interface.

\SysCall{none}{0x00}
{
	Does nothing. This enters and exits the kernel as usual but does nothing else.
}
{
	\SysParmNone
	\SysRetnNone
}

\SysCall{pause}{0x01}
{
	Waits until any event happens to the calling process, or has happened since this call was last made.
	In this context, "any event" refers to the completion or failure of a prior system-call which returned \Const{-{\Undie}SC{\Undie}EAGAIN}.
	
	If an event has already occurred, the call returns immediately.
	If no event has occurred, the calling process will not be scheduled again until it does.
	This is the only way to actually block a process at the kernel level.
	Note that it is likely this system-call returns spuriously.
	It should be used in a loop if busy-waiting on completion of a system-call which is returning \Const{-{\Undie}SC{\Undie}EAGAIN}.
}
{
	\SysParmNone
	\SysRetnNone
}

\SysCall{print}{0xB0}
{
	Prints output to the text-mode screen.
	Prints the sequence of bytes at buf{\Undie}ptr until a terminating NUL.
	Currently supports very few control sequences.
	Basically only used for debugging.
	Returns the number of bytes printed.
	
	Note that this does not cause the text-mode screen to be displayed.
	Call \VarName{{\Undie}sc{\Undie}gfx{\Undie}flip} with parameters of 0 to display the text-mode screen.
}
{
	\SysParm{r1}{const char*}{buf{\Undie}ptr}{Location of data to print.}
	\SysRetn{int}{The number of bytes printed, or a negative error number.}
}	

\subsection{Game input/output}

These system-calls relate to the user's gamepads and television.
No setup or configuration is necessary to use these system-calls.
Each program starts with the audio-visual and input peripherals ready to use.

\SysCall{getticks}{0x02}
{
	Returns the number of milliseconds since the system was booted. Does not fail.	
}
{
	\SysParmNone
	\SysRetn{int}{The number of milliseconds elapsed since boot.}
}


\SysCall{gfx{\Undie}flip}{0x30}
{
	Enqueues a change of the video front-buffer.
	The given buffer will become the front-buffer at the next vertical-blanking interval.
	
	If the given mode is 0, text-mode will be displayed, and buffer must be given as NULL.
	If the given mode is nonzero, a valid buffer must be specified, and large enough for one full-screen image.
	
	Returns the address of the buffer currently displayed. 
	The return value may be 0 if the current front-buffer belongs to another process.
	This call may occasionally take effect immediately, and return its buffer parameter, if the call is made just before vertical blanking.
	\\
	The following mode values are allowed:\\
	\begin{tabular}{l l l}
	Mode & Number & Description \\
	\Const{{\Undie}SC{\Undie}GFX{\Undie}MODE{\Undie}TEXT}          & 0 & No framebuffer; kernel text mode only \\
	\Const{{\Undie}SC{\Undie}GFX{\Undie}MODE{\Undie}VGA{\Undie}16BPP}     & 1 & 640x480@60Hz RGB565, 1280 bytes/line \\ 
	\Const{{\Undie}SC{\Undie}GFX{\Undie}MODE{\Undie}320X240{\Undie}16BPP} & 2 & 320x240@60Hz RGB565, 640 bytes/line
	\end{tabular}
}
{
	\SysParm{r1}{int}{mode}{The video mode in which to display the new buffer.}
	\SysParm{r2}{const void *}{buffer}{The location of the buffer in memory to display.}
	\SysRetn{int}{The currently-displayed image buffer, or a negative error number.}
}

\SysCall{snd{\Undie}play}{0x60}
{
	Enqueues audio samples for playback.
	Samples are read from the given buffer and copied into the kernel for playback.
	Either the whole buffer is consumed or none is.
	The caller may specify the maximum amount of audio to buffer in the kernel.
	This allows trading latency for stability.
	Returns the number of bytes the kernel has still buffered on success, or a negative error number.
	
	The following mode values are allowed:\\
	\begin{tabular}{l l l}
	Mode & Number & Description \\
	\Const{{\Undie}SC{\Undie}SND{\Undie}MODE{\Undie}SILENT}&0 &Stops all sounds \\
	\Const{{\Undie}SC{\Undie}SND{\Undie}MODE{\Undie}48K{\Undie}16B{\Undie}2C}&1 &LPCM, 48KHz, 16b left-then-right, native endian \\
	\end{tabular}
}
{
	\SysParm{r1}{int}{mode}{The audio format of the data in the buffer.}
	\SysParm{r2}{const void *}{chunk}{The location of the buffer in memory to enqueue.}
	\SysParm{r3}{int}{chunkbytes}{The number of bytes in the buffer to enqueue.}
	\SysParm{r4}{int}{maxbuf}{The maximum number of bytes to enqueue in the kernel.}
	\SysRetn{int}{Current buffer usage (bytes) on success, or a negative error number.}
}

\SysCall{input}{0x50}
{
	Reads input events from the system into the given buffer.
	Returns how many events were filled in the buffer, or a negative error number.
	
	The first byte of any event is a character indicating its type. Presently, only the following are defined:
	
	\begin{tabular}{l l l}
	First byte & Total bytes & Event type \\
	\Const{'A'} (\Const{0x41}) & 4 & Player 1 digital gamepad input \\
	\Const{'B'} (\Const{0x42}) & 4 & Player 2 digital gamepad input \\
	\Const{'C'} (\Const{0x43}) & 4 & Player 3 digital gamepad input \\
	\Const{'D'} (\Const{0x44}) & 4 & Player 4 digital gamepad input
	\end{tabular}	
	\\
	The input events defined currently follow the format below:
	
	\begin{tabular}{l l l}
	Offset & Size & Field \\
	0 & 1 & Type \\
	1 & 1 & Unused \\
	2 & 2 & Buttons Pressed
	\end{tabular}
	\\
	The "buttons pressed" field is a bitmask where a 1-bit is a pressed button and a 0-bit is a released button.
	The buttons use the following indexes:
	
	\begin{tabular}{l l l}
	Button & Index & Bitmask \\
	Up     &  \Const{0}    & \Const{0x0001} \\
	Left   &  \Const{1}    & \Const{0x0002} \\
	Down   &  \Const{2}    & \Const{0x0004} \\
	Right  &  \Const{3}    & \Const{0x0008} \\
	A      &  \Const{4}    & \Const{0x0010} \\
	B      &  \Const{5}    & \Const{0x0020} \\
	C      &  \Const{6}    & \Const{0x0040} \\
	X      &  \Const{7}    & \Const{0x0080} \\
	Y      &  \Const{8}    & \Const{0x0100} \\
	Z      &  \Const{9}    & \Const{0x0200} \\ 
	Start  & \Const{10}    & \Const{0x0400} \\
	Mode   & \Const{11}    & \Const{0x0800} \\ 
	\end{tabular}
	\\
	This system-call will typically return an input event per frame per controller port. The buffer should be at least 4-byte-aligned.
}
{
	\SysParm{r1}{{\Undie}sc{\Undie}input{\Undie}t *}{buffer{\Undie}ptr}{The location of the buffer to store the input events.}
	\SysParm{r2}{int}{bytes{\Undie}per{\Undie}event}{The number of bytes in each element of the buffer.}
	\SysParm{r3}{int}{bytes{\Undie}max}{The total size of the buffer in bytes.}
	\SysRetn{int}{The number of events filled or a negative error number.}
}

\subsection{Data access}

\SysCall{disk{\Undie}read2k}{0x91}
{
	Reads 2048-byte sectors from the disk into the given buffer.
	The sector number and count are given in units of 2KByte, i.e. not a byte-offset.
	Returns 0 on success or a negative error number. Any partial completion is considered a failure.
	May return \Const{-{\Undie}SC{\Undie}EAGAIN} if the operation has started and will finish later.
}
{
	\SysParm{r1}{int}{sector{\Undie}num}{Which sector to load from the disk, in units of 2048 bytes.}
	\SysParm{r2}{void *}{buf2k}{The location in memory to store the data being read.}
	\SysParm{r3}{int}{nsectors}{The number of 2048-byte sectors to load.}
	\SysRetn{int}{0 on success, or a negative error number.}
}

\SysCall{disk{\Undie}write2k}{0x92}
{
	Writes 2048-byte sectors to the disk from the given buffer.
	The sector number and count are given in units of 2KByte, i.e. not a byte-offset.
	Returns 0 on success or a negative error number. Any partial completion is considered a failure.
	May return \Const{-{\Undie}SC{\Undie}EAGAIN} if the operation has started and will finish later.
}
{
	\SysParm{r1}{int}{sector{\Undie}num}{Which sector to write on the disk, in units of 2048 bytes.}
	\SysParm{r2}{const void *}{buf2k}{The data in memory to store onto the disk.}
	\SysParm{r3}{int}{nsectors}{The number of 2048-byte sectors to store.}
	\SysRetn{int}{0 on success, or a negative error number.}
}

\SysCall{nvm{\Undie}save}{0x81}
{
	Writes data to the configured nonvolatile memory record, overwriting all previous data.
	The contents should be in the buffer at ``data", of length ``len".
	Writes are atomic and update the whole record each time. No partial writes are possible.
	If no record is configured, this call writes to a temporary per-process buffer instead.
	Returns the number of bytes written on success or a negative error number.
}
{
	\SysParm{r1}{const void *}{data}{Location of data in memory to store to nonvolatile memory.}
	\SysParm{r2}{int}{len}{How many bytes to store.}
	\SysRetn{int}{The number of bytes written or a negative error number.}
}

\SysCall{nvm{\Undie}load}{0x82}
{
	Reads from the configured nonvolatile memory record into the given buffer.
	The buffer to place the results in is at ``buf", of length ``len".
	Reads are protected by SHA256; corruption will result in the file being lost (\Const{-{\Undie}SC{\Undie}ENOENT}).
	If no record is configured, this call reads from a temporary per-process buffer instead.
	Returns the number of bytes read on success or a negative error number.
}
{
	\SysParm{r1}{void *}{buf}{The location in memory to put the data from nonvolatile memory.}
	\SysParm{r2}{int}{len}{How many bytes to load.}
	\SysRetn{int}{The number of bytes read or a negative error number.}
}

\subsection{Process setup}

\SysCall{env{\Undie}save}{0x08}
{
	Appends the given data to the kernel's argument/environment buffer for the calling process.
	Subsequent calls append to the buffer; call with buf=len=0 to reset the buffer.
	This buffer is preserved across calls to exec() and mexec{\Undie}apply().
	Conventionally it should contain a series of NUL-terminated argument strings,
	then an extra NUL, then a series of NUL-terminated environment strings.
	Returns the number of bytes written or a negative error number.
}
{
	\SysParm{r1}{const void *}{buf}{The data in memory to store to the environment buffer.}
	\SysParm{r2}{int}{len}{How many bytes to store.}
	\SysRetn{int}{The number of bytes written or a negative error number.}	
}

\SysCall{env{\Undie}load}{0x09}
{
	Reads from the kernel's argument/environment buffer for the calling process.
	Writes the result into the calling process's user memory, usually after an exec() or mexec{\Undie}apply().
	Unlike {\Undie}sc{\Undie}env{\Undie}save, starts from the beginning each time it's called.
	Returns the number of bytes copied or a negative error number.
}
{
	\SysParm{r1}{void *}{buf}{The location in memory to put the data from the environment buffer.}
	\SysParm{r2}{int}{len}{How many bytes to load.}
	\SysRetn{int}{The number of bytes read or a negative error number.}
}

\SysCall{mexec{\Undie}append}{0xA1}
{
	Appends the given data to the kernel's pending memory image for the calling process.
	Subsequent calls append to the buffer; call with buf=len=0 to reset the buffer.
	The first 4KBytes appended are always inaccessible afterwards and can contain anything.
	The memory at address \MemAddr{0x1000} (+4KBytes in) is where execution starts after {\Undie}sc{\Undie}mexec{\Undie}apply.
	Returns the number of bytes appended on success.
	Returns a negative error number if a failure occurs before any bytes were appended.
}
{
	\SysParm{r1}{const void *}{buf}{The data in memory to append to the new memory space.}
	\SysParm{r2}{int}{len}{How many bytes to append.}
	\SysRetn{int}{The number of bytes appended or a negative error number.}	
}

\SysCall{mexec{\Undie}apply}{0xA2}
{
	Concludes an in-memory exec and replaces the current with the pending image.
	Does not return and does not fail.
	If there is no pending image, the caller exits as though killed by {\Undie}SC{\Undie}SIGSEGV.
}
{
	\SysParmNone
	\SysRetnDead
}

\SysCall{exit}{0x07}
{
	Generally obliterates the calling process.
	Optionally reports a signal that was responsible for its demise.
}
{
	\SysParm{r1}{int}{exitcode}{The return value to report to the parent process.}
	\SysParm{r2}{int}{signal}{The signal number responsible for the exit, if any. Zero otherwise.}
	\SysRetnDead
}

\subsection{Error codes}
The following error codes may be returned by the kernel.
These values are defined as positive integers here.
When returned by a system-call, they are usually negated.
For example, a system-call which fails because there is not enough memory might then return -12.
\\
\\
\begin{tabular}{l l l}
\textbf{Error} & \textbf{Number} & \textbf{Description} \\
\Const{{\Undie}SC{\Undie}EPERM}       &  1 & Operation not permitted. \\
\Const{{\Undie}SC{\Undie}ENOENT}      &  2 & No such file or directory. \\
\Const{{\Undie}SC{\Undie}ESRCH}       &  3 & No such process. \\
\Const{{\Undie}SC{\Undie}EIO}         &  5 & I/O error. \\
\Const{{\Undie}SC{\Undie}ENXIO}       &  6 & No such device or address. \\
\Const{{\Undie}SC{\Undie}E2BIG}       &  7 & Argument list too long. \\
\Const{{\Undie}SC{\Undie}ECHILD}      & 10 & No child processes. \\
\Const{{\Undie}SC{\Undie}EAGAIN}      & 11 & Resource unavailable, try again. \\
\Const{{\Undie}SC{\Undie}ENOMEM}      & 12 & Not enough space. \\
\Const{{\Undie}SC{\Undie}EFAULT}      & 14 & Bad address. \\
\Const{{\Undie}SC{\Undie}EINVAL}      & 22 & Invalid argument. \\
\Const{{\Undie}SC{\Undie}EFBIG}       & 27 & File too large. \\
\Const{{\Undie}SC{\Undie}ENOSPC}      & 28 & No space left on device. \\
\Const{{\Undie}SC{\Undie}EROFS}       & 30 & Read-only file system. \\
\Const{{\Undie}SC{\Undie}ENAMETOOLONG}& 36 & Filename too long. \\
\Const{{\Undie}SC{\Undie}ENOSYS}      & 38 & Functionality not supported. \\
\end{tabular}

\subsection{System calls by number}
The following table lists all system-calls usable by a game, sorted by call number.
\\
\\
\begin{tabular}{l l}
Number & Name\\
\Const{0x00} &\VarName{{\Undie}sc{\Undie}none}\\
\Const{0x01} &\VarName{{\Undie}sc{\Undie}pause}\\
\Const{0x02} &\VarName{{\Undie}sc{\Undie}getticks}\\
\Const{0x07} &\VarName{{\Undie}sc{\Undie}exit}\\
\Const{0x08} &\VarName{{\Undie}sc{\Undie}env{\Undie}save}\\
\Const{0x09} &\VarName{{\Undie}sc{\Undie}env{\Undie}load}\\
\Const{0x30} &\VarName{{\Undie}sc{\Undie}gfx{\Undie}flip}\\
\Const{0x50} &\VarName{{\Undie}sc{\Undie}input}\\
\Const{0x60} &\VarName{{\Undie}sc{\Undie}snd{\Undie}play}\\
\Const{0x81} &\VarName{{\Undie}sc{\Undie}nvm{\Undie}save}\\
\Const{0x82} &\VarName{{\Undie}sc{\Undie}nvm{\Undie}load}\\
\Const{0x91} &\VarName{{\Undie}sc{\Undie}disk{\Undie}read2k}\\
\Const{0x92} &\VarName{{\Undie}sc{\Undie}disk{\Undie}write2k}\\
\Const{0xA1} &\VarName{{\Undie}sc{\Undie}mexec{\Undie}append}\\
\Const{0xA2} &\VarName{{\Undie}sc{\Undie}mexec{\Undie}apply}\\
\Const{0xB0} &\VarName{{\Undie}sc{\Undie}print}\\
\end{tabular}


\section{Timing}

Most video games will need some source of timing information to run correctly.
Neki32 offers a few sources of timing that can be used by a game.

\subsection{Timing sources}
This section covers the valid, proper timing sources that a game can use.

\subsubsection{Timing ticks elapsed}

The most direct timing source is the return value of \VarName{{\Undie}sc{\Undie}getticks}.
This system-call returns the number of milliseconds since the system booted.
It is driven by a hardware timer that is always configured for 1ms intervals.
	
By tracking the change in \VarName{{\Undie}sc{\Undie}getticks}, a game can track elapsed time.

Note that milliseconds will not divide evenly into video frames.
Note also that this count may overflow after about 25 days.

\subsubsection{Timing sound samples played}

Timing can be derived from the amount of audio data sent by the system.

A game can enqueue sound samples for playback with \VarName{{\Undie}sc{\Undie}snd{\Undie}play}.
These samples are played back at a known rate - at the moment, always 48000 per second.

The \VarName{{\Undie}sc{\Undie}snd{\Undie}play} system-call returns the number of samples currently in the queue.
It also bails out, returning \Const{-{\Undie}SC{\Undie}EAGAIN}, if too many samples are enqueued already.
	
Either one of these situations provides information about how many samples have been played.

A game can track elapsed time by how many times it has successfully enqueued some number of audio samples.
To gain precision, it could also inspect how many samples are currently enqueued each time.

\subsubsection{Timing video frames flipped}

Timing can be derived as well from how many video frames have been presented.
This approach is very common in older console games.

A game can call \VarName{{\Undie}sc{\Undie}gfx{\Undie}flip} to enqueue a change of the video front-buffer.
The system-call returns the location of the buffer currently being displayed.
The buffer displayed - and therefore the return value - only changes when the video display enters vertical-blanking.

Therefore, a game can see how many vertical-blanking intervals have elapsed, in how many times it can change the front-buffer.

Note that it is possible to "miss" blanking intervals if the game is checking less often than 1/60s (in other words, if the game is running too slow).

\subsection{Not timing sources}
There are also some features of Neki32 which might seem like they provide timing, but do not.
Games which attempt to use this approaches for timing are not expected to work on future software or hardware revisions.
	
\subsubsection{Not a timing source: The CPU}

Neki32 currently ships with a single known ARM9 CPU. However, for future-compatibility, do not assume that the CPU speed is known.
Later hardware revisions may run slightly faster in some scenarios. Larger caches or different memory technologies may also impact instruction throughput.

Do not assume that timing based on execution speed is reliable.

\subsubsection{Not a timing source: input events from \VarName{{\Undie}sc{\Undie}input}}

At the moment, Neki32 reports a consistent number of input events per video frame.
However, this is not guaranteed. More or less input events may be reported in a given time.

Do not assume that one input report corresponds to one video frame.

\subsubsection{No rational relationships}

Current Neki32 firmware tends to have a rational relationship between the different timing sources.
They are all derived from the same 24MHz crystal and therefore have fixed ratios to each other.
However, this is not guaranteed.

Do not assume that a given number of video frames, audio samples, or timer ticks will bear a fixed relationship to other timing sources.



\section{The C SDK}
The C SDK is an easy way to start writing programs for Neki32.
It provides a runtime environment that behaves like a POSIX-compatible system, such as Linux or FreeBSD.
The SDK includes the following parts.
\subsection{SDK Contents}
\subsubsection{Compiler Wrappers}
The compiler wrappers help to invoke GCC or LLVM with the right options for building a Neki32 executable.
You must have an appropriate GCC or LLVM compiler installed, of course. It needs to be able to target the ARMv5TE architecture.
\subsubsection{C Runtime}
The C Runtime is what initially starts running when the Neki32 kernel loads your program.
It initializes the environment and filesystem, and calls your main function.
It also contains the linker configuration, so the linker can make an executable in the right format (a flat 0-based binary).
\subsubsection{Picolibc}
This is a port of PicoLibC to the Neki32. PicoLibC is a portable C Standard Library. It provides functions like printf and strcpy.
\subsubsection{PVMK OS library}
The OS Library is a link between the PicoLibC code and the system-calls available on the Neki32.
It handles some things that aren't implemented in the ``PVMK'' kernel itself.

For example, the system-call interface on Neki32 provides block-level access to sectors from the game card.
The system doesn't care what kind of filesystem is on the card.
So, when your application calls fopen(), someone has to go understand the filesystem on the card and find the file you wanted.
The code is in this library, so you can open/read/close like normal.
\subsubsection{Updates Package}
This is the official Neki32 system-update package from Nekisoft.
This can be included on game media to ensure that players have the latest system software.
Note that a license is required to distribute this - you must adhere to our software quality and marketing guidelines.
See the licensing section for more information.
\subsubsection{SDL System-Call Shims}
This is an implementation of some system-calls on top of the SDL2 library.
Using this, instead of the real system-call library, you can build and test your code on a desktop Linux machine.
Then, you could compile the same application for Neki32 with minimal changes.

\section{Examples}
\subsection{Development workflows}
\subsubsection{Just Assembly}
It is possible to make a bootable Neki32 game card using only an ARM assembler. The executable code can be written in assembly, of course.
The same assembly can also be used to make structures for ISO9660 and El Torito, referencing the executable code.
For simplicity, we can place the executable at the beginning of the disk image.
Then, a byte location in the disk, the executable, and the process memory are all the same.
The output of the assembler is directly used as the disk image.

This approach can be used for simple games which fit entirely into the 24MByte RAM budget of the Neki32.
That's 5 times bigger than the biggest Genesis cartridge!

Source code for this example is found in \PathName{examples/allasm} in the SDK.
It doesn't require anything but GNU Make and the GNU Assembler for ARM.

\subsubsection{Assembly and some Data}
A program running on the Neki32 can load more data off the game card.
The system-call \VarName{{\Undie}sc{\Undie}disk{\Undie}read2k} is used to perform this operation.
The previous example can be extended to load more data off the game card, after the boot program is already running.

This approach can be used for games which swap out graphical assets in simple ways.
It has some advantages over using a filesystem - namely, that all locations are resolved at link-time.
This makes the game a bit faster and more reliable.
No overhead is spent accessing file metadata.

Source code for this example is found in \PathName{examples/asmdata} in the SDK.
It doesn't require anything but GNU Make and the GNU Assembler and linker for ARM.

\subsubsection{Assembly Accessing a Filesystem}

For games with lots of data, it is helpful to keep the data in a filesystem.
This aids in managing the data during development, and makes the environment more similar to a desktop workstation.

The ISO9660 filesystem is simple enough that it can be parsed from assembly code.
The assembly code can then access any number of different files included in the ISO9660 filesystem.

In this case, the assembler is used to make an executable by itself (we call this format a ``no-nonsense executable'', or NNE).
Then, mkisofs is used to put this executable in a bootable El Torito / ISO9660 image.
Other files containing data are also placed in the image.
Once running, the code can look through the ISO9660 filesystem to find its data files.

Source code for this example is found in \PathName{examples/asmisofs} in the SDK.
It requires GNU Make and the GNU Assembler and linker for ARM, as well as the mkisofs utility.

\subsubsection{Adding some Freestanding C}

It is unlikely that you want to write an entire game in assembly.
The previous examples can be extended by linking them against freestanding C code.
This provides a barebones environment, lacking a standard library.
It does, however, allow writing C while retaining control of the entire resulting executable.

Source code for this example is found in \PathName{examples/freestanding} in the SDK.
It requires GNU Make and the GNU Assembler and linker for ARM, as well as the mkisofs utility, and the GNU C Compiler for ARM.

\subsubsection{Using the C SDK Instead}

For convenience, a C SDK is provided which gets the basics of a C runtime environment handled.
It includes a port of Picolibc with an ISO9660 implementation providing file access via \VarName{{\Undie}sc{\Undie}disk{\Undie}read2k}.
It also includes startup files necessary to call \VarName{main()} in a sane way.

Source code for this example is found in \PathName{examples/sdkusage} in the SDK.
It requires the SDK to be set up properly, including the GNU ARM toolchain and the C Runtime and C Standard Library for Neki32.

\subsection{System call usage}

\subsubsection{Reading inputs}

It is straightforward to read user input on the Neki32.
A single system-call is used to retrieve user input as a series of events.
Each event starts with a byte identifying what type of event it is. Then, event data follows. 

A single invocation of the system-call may return multiple events in an array.
The caller specifies the size of each array element, and the overall size of the array.
The game knows, of course, the largest event it will handle, and can size its array elements appropriately.
Array entries are zero-filled if the event is smaller. Events are truncated if they do not fit.

Right now all events are 4 bytes in length.
A single character identifies which controller port is considered, ``A", ``B", ``C", or ``D" (ASCII codes 0x61, 0x62, 0x63, 0x64).
Then, one dummy byte is usually zero.
Then a 16-bit value identifies which buttons are pressed as a bit-map.

The format of the input event and the button bitmasks are defined in \PathName{sc.h} in the C SDK.
This example reads input from all 4 players and displays their control data on screen.

Source code for this example is found in \PathName{examples/showinput} in the SDK.
It requires the SDK to be set up properly, including the GNU ARM toolchain and the C Runtime and C Standard Library for Neki32.

\subsubsection{Double-buffered animation}

Double-buffering can be used to synchronize the game code and video output.
This is the simpler option, in contrast to triple-buffering.

Double-buffering means that memory for two video frames is used.
At any time, one is used by the CPU to draw the next frame, while the other is being sent to the TV.
The buffer that the CPU accesses is called the back buffer, and the buffer being sent to the TV is the front buffer.
Note that it takes almost an entire frame of time, to send that one frame of data to the TV.

The TV is given some free time between bursts of video data, called ``blanking". When the TV is in blanking, no data is sent to it.
At the end of each line in a frame, there is a ``horizontal blanking" time. Horizontal blanking is very short in duration.
At the end of each frame, there is a ``vertical blanking" time.

During vertical blanking, there is about 1ms when no data is sent. A complete frame has already been transmitted.
At this time, the buffers can be interchanged, called ``swapping'' or ``flipping'' the buffers.
Then the CPU can re-draw to the buffer which was previously displayed, as the next one is sent to the TV.
In this way, a series of complete frames is sent to the TV.

In double-buffering on Neki32, the \VarName{{\Undie}sc{\Undie}gfx{\Undie}flip} system call is used in a loop with \VarName{{\Undie}sc{\Undie}pause}.
Until \VarName{{\Undie}sc{\Undie}gfx{\Undie}flip} indicates that the desired buffer is being displayed, the game continues to pause.
Effectively, the game blocks on the ``flip'' syscall and proceeds when the new image is displayed.

Source code for this example is found in \PathName{examples/dblbuf} in the SDK.

\subsubsection{Triple-buffered animation}

Triple-buffering is more complicated than double-buffering, but has some speed advantages.
At any time, one image is being sent to the TV, one is being drawn by the CPU, and one is kept spare.

In double-buffering, if the CPU has finished drawing a frame, it must wait for the prior frame to be entirely sent to the TV.
In triple-buffering, an additional spare buffer is kept. Therefore, the CPU can move on to render the following frame immediately.
If the CPU is running fast, it can continue to render a series of frames, independently of the TV scanout.
It ping-pongs between the two buffers which are not being sent to the TV. 
Whenever one frame is done being sent to the TV, there is always another complete frame ready to go.

This requires three frame buffers to be allocated instead of two, of course.
When \VarName{{\Undie}sc{\Undie}gfx{\Undie}flip} is called, the game does not wait on its result.
Instead, the game evaluates the situation and continues each time it calls \VarName{{\Undie}sc{\Undie}gfx{\Undie}flip}.
The parameter to \VarName{{\Undie}sc{\Undie}gfx{\Undie}flip} will be enqueued for display at the next vertical-blanking interval.
The return value from \VarName{{\Undie}sc{\Undie}gfx{\Undie}flip} is the buffer currently displayed, at that moment.
Therefore, the game finds whichever buffer is neither of those. It continues rendering into that one.

Source code for this example is found in \PathName{examples/tplbuf} in the SDK.

\subsubsection{Saving saves}
It is simple to save the player's progress to Nonvolatile Memory in the console.

An area of memory can be allocated in the game process, big enough to hold the saved data.
When the game starts, the system-call \VarName{{\Undie}sc{\Undie}nvm{\Undie}load} is used to populate the area with the saved data.
Then, whenever appropriate, the system-call \VarName{{\Undie}sc{\Undie}nvm{\Undie}save} can be used to store it back to the console.

It is only necessary to check, on start-up, that the region is not all \Const{0x00}.
In this case, no data was previously saved, and the savegame region should be initialized in RAM before calling \VarName{{\Undie}sc{\Undie}nvm{\Undie}save}.

It is not necessary to handle failures to save, or corruption from interrupted saves.
The system will make sure there is space allocated, at boot, before the game executes.
The system will keep checksums and double-buffer the saved data, to protect against data loss.
Physical writes are ordered to ensure reliability.

Source code for this example is found in \PathName{examples/nvmsave} in the SDK.

\subsection{SDK features}

The C SDK includes a mostly-complete C standard library that enables many POSIX-like operations.

\subsubsection{Writing to files}

Ordinarily, we recommend that a game card is permanently write-protected, to protect against damage.
Savegames can be written to the Nonvolatile Memory in the console in this case, so no special SD card is needed.
However, the system supports writing back to game cards if you want to.

The SDK includes support for overwriting file contents on an ISO9660 filesystem.
Files cannot be created or deleted, or their length changed.
However their contents, at their existing location and length, can be modified.
The actual writes are performed when the SDK calls \VarName{{\Undie}sc{\Undie}disk{\Undie}write2k}.

The example in \PathName{examples/rwcard} uses this to save data which the user has modified.
It contains an existing file in the ISO9660 image, called SAVE.BIN, whose contents are modified at runtime.

\section{Common errors}
This section contains examples of why a program may not work as expected. 
\subsection{System call failures}
Most system-calls in PVMK will always complete predictably if given valid parameters.
Unexpected failures are rare due to the restricted nature of the environment.
An enumeration of system-calls and potential failures follows.
\\

\subsubsection{\Const{0x00} \VarName{{\Undie}sc{\Undie}none}}
\BL This call cannot fail.
\BL In some sense, it also cannot succeed.

\subsubsection{\Const{0x01} \VarName{{\Undie}sc{\Undie}pause}}
\BL This call cannot fail.
\BL Note that this call may return spuriously for a number of reasons. A previous system-call may have triggered an unpause which has been ignored. Or, the timing of a following system-call may not be predictable.
\BL To block waiting on a system-call result, retry the call, and use \VarName{{\Undie}sc{\Undie}pause} in a loop. Call pause if and only if an \Const{-{\Undie}SC{\Undie}EAGAIN} result is returned from the call in question.

\subsubsection{\Const{0x02} \VarName{{\Undie}sc{\Undie}getticks}}
\BL This call cannot fail. 
\BL Note that this returns ticks since the system booted, not since the program began executing. 
\BL When using the debugger, this may also show discontinuities. 
\BL The units are milliseconds. As the value is 32-bit, the tick count may overflow if the user leaves the console running for 25 days. Games do not need to handle this, but may choose to handle the overflow or to crash.

\subsubsection{\Const{0x07} \VarName{{\Undie}sc{\Undie}exit}}
\BL This call cannot fail. 
\BL The system may try to re-launch a game that exits, up to 3 times.

\subsubsection{\Const{0x08} \VarName{{\Undie}sc{\Undie}env{\Undie}save}}
\BL This call can fail if the buffer is not in valid memory. 
\BL This call can fail if the environment buffer is already full. 
\BL This call can fail if the pointer is NULL but the length is nonzero. 
\BL This call can fail if the length is zero but the pointer is non-NULL. 
\BL This call can fail if the length is too large for the environment at all. 
\BL Note that subsequent calls append to the buffer, not starting again. 

\subsubsection{\Const{0x09} \VarName{{\Undie}sc{\Undie}env{\Undie}load}}
\BL This call can fail if no data is in the environment buffer already. 
\BL This call can fail if the buffer is not in valid memory. 
\BL This call can fail if the given buffer is too small for the environment stored. 
\BL Note that subsequent calls do not continue reading from the buffer, instead starting again. 

\subsubsection{\Const{0x30} \VarName{{\Undie}sc{\Undie}gfx{\Undie}flip}}
\BL This call can fail if an invalid buffer pointer is given. 
\BL This call can fail if an invalid mode value is given. 
\BL This call can fail if the mode is ``text" mode (0) but the buffer is non-NULL. 
\BL This call can fail if the mode is not ``text" (nonzero) but the buffer is NULL. 
\BL This call can occasionally return the buffer it was given, immediately. This happens if the call is made just as the system enters vertical blanking. 
\BL This call can return 0 if the currently-displayed buffer belongs to another process. 

\subsubsection{\Const{0x50} \VarName{{\Undie}sc{\Undie}input}}
\BL This call can fail if the buffer is not in valid memory. 
\BL This call can fail if the buffer sizes are zero or negative. 
\BL This call can fail if the buffer size overall is not a multiple of the buffer element size. 

\subsubsection{\Const{0x60} \VarName{{\Undie}sc{\Undie}snd{\Undie}play}}
\BL This call can fail if the chunk size is too large for the kernel to buffer at all. 
\BL This call can fail if the maximum buffered size is set too low. 
\BL This call can fail if the buffer is not in valid memory. 
\BL This call can fail if the mode given is invalid. The only valid mode currently is 1. 

\subsubsection{\Const{0x81} \VarName{{\Undie}sc{\Undie}nvm{\Undie}save}}
\BL This call can fail if the buffer pointer and length do not refer to valid memory. 
\BL This call can fail if the buffer is oversized. 
\BL If the game did not provide a valid name in its ISO9660 Primary Volume Descriptor, this call will not actually write to nonvolatile memory.
\BL If the user chose not to make space for the game, this call will not actually write to nonvolatile memory.
\BL In cases where no nonvolatile memory record is prepared, this call writes to a temporary buffer for the process instead.

\subsubsection{\Const{0x82} \VarName{{\Undie}sc{\Undie}nvm{\Undie}load}}
\BL This call can return 0 bytes if the save record was just created.
\BL This call can fail for the same reasons as \VarName{{\Undie}sc{\Undie}nvm{\Undie}save}. 

\subsubsection{\Const{0x91} \VarName{{\Undie}sc{\Undie}disk{\Undie}read2k}}
\BL This call can fail if the sector number is invalid. 
\BL This call can fail if the buffer is not in valid memory. 
\BL This call can fail of the number-of-sectors parameter is less than 1 or greater than 12288.

\subsubsection{\Const{0x92} \VarName{{\Undie}sc{\Undie}disk{\Undie}write2k}}
\BL This call can fail if the sector number is invalid.
\BL This call can fail if the buffer is not in valid memory.
\BL This call can fail if the card is write-protected. 
\BL This call can fail of the number-of-sectors parameter is less than 1 or greater than 12288.
\BL It is not recommended to use this call unless the card can be partially write-protected.

\subsubsection{\Const{0xA1} \VarName{{\Undie}sc{\Undie}mexec{\Undie}append}}
\BL This call can fail if the pending memory image is already too large. 
\BL This call can fail if the given buffer is not in valid memory. 
\BL This call can fail if the given buffer is too large for the pending memory image. 
\BL This call can fail if the buffer pointer is NULL but the length is nonzero. 
\BL This call can fail if the buffer length is zero but the pointer is non-NULL. 

\subsubsection{\Const{0xA2} \VarName{{\Undie}sc{\Undie}mexec{\Undie}apply}}
\BL This call cannot fail. 
\BL If the pending memory image is not valid, the process will die from a segfault. 

\subsubsection{\Const{0xB0} \VarName{{\Undie}sc{\Undie}print}}
\BL This call can fail if the buffer is not in valid memory. 

\subsection{Crashes}

A processor exception will result in a signal, killing the game process.
The following things can cause this:

\BL Accessing an invalid memory location will cause \Const{SIGSEGV}.
\\
Valid memory locations start at \MemAddr{0x1000} and extend to one byte before the size of the process.
The size of the game process, by default, is always \Const{24*1024*1024} (24 megabytes).
If \VarName{{\Undie}sc{\Undie}mexec{\Undie}apply} has been used to load a new program, the process size is the total number of bytes appended by \VarName{{\Undie}sc{\Undie}mexec{\Undie}append} beforehand.
Note that the caller is required to set the total size of the new process, including the \VarName{.bss} section, by appending that many bytes.
New memory cannot be added to the process once it is running.

\BL Accessing a misaligned word or halfword will cause \Const{SIGBUS}.
\\
Memory accesses on ARM must be naturally-aligned.
This means that a 32-bit (word) access must be to an address which is a multiple of \Const{4}, and a 16-bit (halfword) access must be to an address which is a multiple of \Const{2}.
Otherwise, an alignment-check fault results and causes this signal.

\BL Executing an undefined instruction will cause \Const{SIGILL}.
\\
The Neki32 supports the ARMv5TE instruction set.
It additionally uses a single architecturally-undefined instruction, \Instr{udf 0x92}, to initiate a system-call.
Any instructions outside this set will trigger an undefined opcode fault and raise this signal.

\BL System-calls do not work from Thumb mode.
\\
Currently the system only supports the ARM encoding of the \Instr{udf 0x92} instruction (\Const{0xe7f009f2}).
Thumb code therefore must switch back to ARM mode to execute a system-call.

\section{Secret Codes}

These features of the Neki32 console may assist in development.

\subsection{At power-on}

The Neki32 console stores its default system software, called Kernel Zero, in read-only memory.
It can also store a single updated version of the system software.
If the updated version is valid, it will be booted automatically instead of the original.
To boot the original version instead of the updated version, hold the Down direction on controller D while turning the system on.

If system software updates are present on a game card, the system will find the newest one matching the hardware.
It will prompt the user to update if it is newer than the current version.
To force this prompt to always appear, regardless of the version numbers, hold Y on controller A while turning the system on.
To skip this prompt, regardless of the version numbers, hold X on controller A while turning the system on.

\subsection{At the boot menu}

Some additional information is available from the Neki32 system menu.
To see additional hardware test features, enter the code ``XYZZY" on controller A at the main menu.
To see the version number, and a message about why no game was booted, hold the Z and Mode buttons on controller A at the main menu.

\end{document}