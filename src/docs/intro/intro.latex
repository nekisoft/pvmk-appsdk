%intro.latex
%Introductory document for Neki32 developers
%Bryan E. Topp <betopp@betopp.com> 2024

\documentclass[12pt]{article}

\usepackage{geometry}
\usepackage{comment}
\usepackage{courier}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\hypersetup{linktoc=all}

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,linewidth=\textwidth}

%In case we want fancy type like the LaTeX logo
\def\Neki32{{Neki32}}

%For underscores in variable names
\def\Undie{{\_}}

%Formatting of memory addresses, registers, etc
\newcommand{\MemAddr}[1]{\texttt{#1}}
\newcommand{\Reg}[1]{\texttt{#1}}
\newcommand{\Const}[1]{\texttt{#1}}
\newcommand{\Instr}[1]{\texttt{#1}}
\newcommand{\CType}[1]{\texttt{#1}}
\newcommand{\VarName}[1]{\texttt{#1}}

%Formatting of system-call listings
\newcommand{\SysCall}[4]{\subsubsection{\texttt{{\Undie}sc{\Undie}#1}} Called with: \Reg{r0} = \Const{#2}. \\ #3 \begin{itemize} #4 \end{itemize}}
\newcommand{\SysParm}[4]{\item \Reg{#1} : \CType{#2} \VarName{#3}\\ #4 }
\newcommand{\SysRetn}[2]{\item Returns : \CType{#1} \\ #2}
\newcommand{\SysParmNone}[0]{\item No parameters. }
\newcommand{\SysRetnNone}[0]{\item No return value. }
\newcommand{\SysRetnDead}[0]{\item This call does not return. }

\begin{document}

\author{Nekisoft Pty Ltd}
\title{\includegraphics[width=10cm]{logo.png}\\The \Neki32 Software Development Manual}
\date{\today}
\maketitle
\pagebreak

\tableofcontents

\pagebreak

\section*{Preface}

Numbers are in decimal (base-10) unless otherwise stated.\\
Numbers beginning with a \Const{0x} prefix are hexadecimal (base-16).
\\
\\
\copyright2024 Nekisoft Pty Ltd\\
Australian Company Number 680 583 251

\section{Introduction}

Thank you for your interest in developing software for \Neki32!

\subsection{What is \Neki32?}

\Neki32 is a 32-bit game console that delivers a fast no-nonsense experience to both gamers and game developers.
The system runs on an ARM9 CPU clocked at 300MHz. Up to 24MBytes of memory is available for the game process.
Software-rendering is used to produce bitmapped graphics and digital sound.

An operating system hides details of the hardware.
The application format and interface is kept to a minimum.

The \Neki32 console itself is powered by USB-C.
It outputs audio and video to an HDMI TV.
Games are distributed on read-only SD cards. 
There are four controller ports, compatible with Genesis and Mega-Drive controllers.
There is 4MBytes of internal memory for savegames of 128KBytes per game.

(Picture of the console goes here.)

\pagebreak

\subsection{Technical Specifications}
\begin{itemize}
	\item Power input:
	\begin{itemize}
		\item Connector: USB-C compatible\footnote{The \Neki32 console is not USB\texttrademark{}-certified but should work with any USB-C power supply.}
		\item Voltage: \(5V \pm 10 \% \)
		\item Current: \(\leq 100mA\)
	\end{itemize}
	\item A/V output:
	\begin{itemize}
		\item Connector: HDMI compatible\footnote{It is is also not HDMI\texttrademark{}-certified but should work with any HDMI television.}
		\item Resolution: 640x480, or 320x240 with pixel-doubling
		\item Refresh rate: 60Hz
		\item Aspect ratio: 4:3
		\item Color depth: 16 bits per pixel, RGB565
		\item Audio format: 48KHz 16-bit stereo LPCM
	\end{itemize}
	\item User inputs:
	\begin{itemize}
		\item Connector: 9-pin D-Sub (male) x4
		\item Layout: 8-way directional pad, 6 face buttons, 2 menu buttons
		\item Protocol: Mega-Drive compatible\footnote{Mega-Drive\texttrademark{} is owned by Sega and used without permission. They are unaffiliated with us.}
	\end{itemize}
	\item Game media:
	\begin{itemize}
		\item Connector: SD/MMC card (full-size)
		\item Capacity: 16MBytes to 2TBytes
		\item Format: El-Torito bootable image, platform \Const{0x92}
	\end{itemize}
\end{itemize}

\pagebreak

\subsection{Overview of a Game}

A Neki32 game is quite simple. It is an SD card containing a program to run and possibly other data. Very little is necessary to get code running.

The card is read-only and formatted much like an optical disc.
It contains an El Torito boot record for platform \Const{0x92}.
The El Torito boot record points at the executable file for the game.

The game executable is a flat, 0-mapped binary image of the game's initial memory content.
For example, if the game executable is 3MBytes in size, the system will load it into virtual memory addresses \MemAddr{0} to \MemAddr{3145727}.
The zero page, afterward, is inaccessible. Memory from addres \MemAddr{0} to \MemAddr{4095} always faults.
A small magic number is placed here instead.

The game starts execution at address \MemAddr{4096}, the first accessible address.
All registers are zeroed on entry.
The process starts in ARM mode but may switch to Thumb mode at its choice.

System-calls can be made using a \Instr{svc 0x92} instruction.
The call number is placed in \Reg{r0}, while parameters are placed in \Reg{r1} through \Reg{r5}.
Return values are left in \Reg{r0} after the call is performed.

Exceptions are delivered to the game process as a signal.
Signals are initially blocked. An exception causing a blocked signal will terminate the process.
A signal can be unblocked and handled instead.
In this case, it causes the process to restart to address \MemAddr{4096} with the signal number in \Reg{r0}. A system-call is used to return from the signal.

\section{The boot process}
The boot process treats the game card like an optical disc - it is read-only and organized in naturally-aligned 2048-byte sectors.
Sector \MemAddr{0} contains bytes \MemAddr{0} to \MemAddr{2047}, sector \MemAddr{1} contains bytes \MemAddr{2048} to \MemAddr{4095}, and so on.

\subsection{The beginning of the media}

The system first reads sectors \Const{0x10} and \Const{0x11}.
Sector \Const{0x10} always contains the ISO9660 Primary Volume Descriptor, describing the game media.
The ISO9660 Primary Volume Descriptor gives the name of the media, in a \Const{32}-byte field at offset \Const{40}.
If this is present, not entirely whitespace, and not \Const{CDROM} or \Const{cdrom}, it is taken to be the game's name.

Sector \Const{0x11} always contains the El Torito Boot Volume Descriptor, describing the boot information.
The El Torito Boot Volume Descriptor, from sector \Const{0x11}, is used to locate an El Torito Boot Catalog.
The El Torito Boot Volume Descriptor must contain the magic value \Const{EL TORITO SPECIFICATION} at offset \MemAddr{7}.
It also contains the sector number of the El Torito Boot Catalog, as a 32-bit little-endian number at offset \MemAddr{0x47}.
This is taken to be in units of \Const{2048} bytes, from the beginning of the game media.

\subsection{The boot catalog}
The system reads the El Torito Boot Catalog from the sector number given in the El Torito Boot Volume Descriptor.
Only one sector is read, even though El Torito allows for larger boot catalogs.
The Boot Catalog consists of \Const{32}-byte entries, naturally-aligned.
The first entry must start with the following one-byte magic values:

\begin{tabular}{ r r }
Offset & Value \\
\MemAddr{0x00} & \Const{0x01} \\
\MemAddr{0x1E} & \Const{0x55} \\
\MemAddr{0x1F} & \Const{0xAA}
\end{tabular}

Following this, entries begin with a one-byte value specifying their type, a single byte at offset \MemAddr{0}.

Types \Const{0x01}, \Const{0x90}, or \Const{0x91} begin a section of the Boot Catalog, and contain a Platform ID for entries that follow.
The platform ID is located at offset \MemAddr{1} in such an entry.
The platform ID for a \Neki32 application is \Const{0x92}. A boot entry following this platform will contain game code.
The platform ID for a \Neki32 system-update bundle is \Const{0x22}. A boot entry following this platform will contain packaged system-update data from Nekisoft.

Type \Const{0x88} indicates a bootable entry.
The platform ID of the bootable entry is given in a preceding section entry.
The length of the bootable payload is given as a 2-byte little-endian value at offset \MemAddr{6}. The length is given in units of \Const{512} bytes.
The location of the bootable payload is given as a 4-byte little-endian value at offset \MemAddr{8}. The location is given in units of \Const{2048} bytes, relative to the beginning of the game media.

The first bootable entry of platform ID \Const{0x92} is taken to be the game executable to boot.
The first bootable entry of platform ID \Const{0x22} is taken to be the system update package to examine, if any.
The format of the system update package is not described here.
It should be obtained from Nekisoft and included verbatim.

\subsection{The game executable}

Once the location of the game executable is found in the El Torito Boot Catalog, the system begins to load it.
The game executable is loaded into a new virtual memory space, by itself.
The virtual memory space starts at address \MemAddr{0} and extends to the size specified in the El Torito Boot Catalog.
As the size is given as a 16-bit number in units of \Const{512} bytes, up to 32MBytes could be specified.
However, a game on Neki32 is limited to 24MBytes of memory at any time.

After loading, the zero page is checked for an appropriate magic number.
The first eight bytes should be \Const{NNEARM32}.
The second eight bytes should be the entry point as a 64-bit little-endian value.
This value must always be \MemAddr{0x1000}.

Once the game executable is loaded, the game process starts executing it from \MemAddr{0x1000}, with all registers zeroed.
The game must then make its first system-call with \Reg{r0} set to \Const{0xFF} and \Reg{r1} set to \Const{1} to declare the version of the system ABI it expects.

\subsection{Failures}

If any of these steps encounters a missing magic-number or a failure to read the game media, the booting process stops.
Instead of launching the game, the console will drop to its system menu.
The system menu allows users to see the data saved on their console or turn it off.

\section{The instruction set}

The game executable runs in user-mode on an ARMv5TE processor, including both ARM and Thumb modes.
The system will always start executing the game in ARM mode, with the program counter at \MemAddr{0x1000}.
Thumb interworking instructions may be used to transfer into and out of Thumb mode.

No floating-point instructions are available.
Floating-point emulation works well enough to run Quake, at least, if you really want that.

The \Instr{svc 0x92} instruction is used to trigger system-calls. Other \Instr{svc} instructions should not be used.

\pagebreak
\section{System calls}

System-calls are used to access hardware features in a backward- and forward-compatible way.
The system-call interface for Neki32 comprises 21 different calls.

To run a system call, first place its inputs in CPU registers. The call number is passed in register \Reg{r0}.
Parameters, if any, are passed in registers \Reg{r1} to \Reg{r5}. Then, use the \Instr{svc 0x92} instruction.
The kernel will perform the requested operation.
The return value is stored in \Reg{r0} after the call finishes.

Typically, system-calls will return a negative error number if they fail, or a nonnegative value on success.
They may read or write in the memory of the caller.

System-calls are nonblocking. If a long-term operation is started, its system-call returns with \Const{-{\Undie}SC{\Undie}EAGAIN}.
The call can be repeated until it completes, returning a successful result.
In the mean time, the \Const{{\Undie}sc{\Undie}pause} system-call can be used to block the caller.
For example, the following code would wait for any input events:
\begin{lstlisting}[language=C]
_sc_input_t mybuf[8] = {0};
while(_sc_input(mybuf, sizeof(mybuf[0]), sizeof(mybuf)) == -_SC_EAGAIN)
{
	_sc_pause();
}
\end{lstlisting}

\subsection{Basics}

These system-calls relate to the general usage of the system-call interface.
A call to \Const{{\Undie}sc{\Undie}version} must be the first system-call made when a new program is loaded.
Otherwise, any other system-calls will fail and return \Const{-{\Undie}SC{\Undie}ENOSYS}.

\SysCall{version}{0xFF}
{
	Selects the version of the operating system ABI in use by the caller.
	The kernel will return the best compatible ABI version it can provide.
	If the kernel is simply incompatible, a negative error number will be returned.
	Presently, version 1 is defined. All kernels will support version 1.
	All applications must, at this time, request version 1.
}
{
	\SysParm{r1}{int}{version}{The desired version of the system-call interface. Should be 1.}
	\SysRetn{int}{The version of the system-call interface that the kernel will use.}
}

\SysCall{none}{0x00}
{
	Does nothing. This enters and exits the kernel as usual but does nothing else.
}
{
	\SysParmNone
	\SysRetnNone
}

\SysCall{pause}{0x01}
{
	Waits until any event happens to the calling process, or has happened since this call was last made.
	
	If an event has already occurred, the call returns immediately.
	If no event has occurred, the calling process will not be scheduled again until it does.
	This is the only way to actually block a process at the kernel level.
	
	In this context, "any event" refers to the completion or failure of a prior system-call which returned \Const{-{\Undie}SC{\Undie}EAGAIN}.
}
{
	\SysParmNone
	\SysRetnNone
}

\subsection{Game input/output}

These system-calls relate to the user's gamepads and television.
No setup or configuration is necessary to use these system-calls.
Each program starts with the audio-visual and input peripherals ready to use.

\SysCall{getticks}{0x02}
{
	Returns the number of milliseconds since the system was booted. Does not fail.	
}
{
	\SysParmNone
	\SysRetn{int}{The number of milliseconds elapsed since boot.}
}


\SysCall{gfx{\Undie}flip}{0x30}
{
	Enqueues a change of the video front-buffer.
	The given buffer will become the front-buffer at the next vertical-blanking interval.
	
	If the given mode is 0, text-mode will be displayed, and buffer must be given as NULL.
	If the given mode is nonzero, a valid buffer must be specified, and large enough for one full-screen image.
	
	Returns the address of the buffer currently displayed. 
	The return value may be 0 if the current front-buffer belongs to another process.
	This call may occasionally take effect immediately, and return its buffer parameter, if the call is made just before vertical blanking.
	\\
	The following mode values are allowed:\\
	\begin{tabular}{l l l}
	Mode & Number & Description \\
	\Const{{\Undie}SC{\Undie}GFX{\Undie}MODE{\Undie}TEXT}          & 0 & No framebuffer; kernel text mode only \\
	\Const{{\Undie}SC{\Undie}GFX{\Undie}MODE{\Undie}VGA{\Undie}16BPP}     & 1 & 640x480@60Hz RGB565, 1280 bytes/line \\ 
	\Const{{\Undie}SC{\Undie}GFX{\Undie}MODE{\Undie}320X240{\Undie}16BPP} & 2 & 320x240@60Hz RGB565, 640 bytes/line
	\end{tabular}
}
{
	\SysParm{r1}{int}{mode}{The video mode in which to display the new buffer.}
	\SysParm{r2}{const void *}{buffer}{The location of the buffer in memory to display.}
	\SysRetn{int}{The currently-displayed image buffer, or a negative error number.}
}

\SysCall{snd{\Undie}play}{0x60}
{
	Enqueues audio samples for playback.
	Samples are read from the given buffer and copied into the kernel for playback.
	Either the whole buffer is consumed or none is.
	The caller may specify the maximum amount of audio to buffer in the kernel.
	This allows trading latency for stability.
	Returns 0 on success, or a negative error number.
	
	The following mode values are allowed:\\
	\begin{tabular}{l l l}
	Mode & Number & Description \\
	\Const{{\Undie}SC{\Undie}SND{\Undie}MODE{\Undie}SILENT}&0 &Stops all sounds \\
	\Const{{\Undie}SC{\Undie}SND{\Undie}MODE{\Undie}48K{\Undie}16B{\Undie}2C}&1 &LPCM, 48KHz, 16b left-then-right, native endian \\
	\end{tabular}
}
{
	\SysParm{r1}{int}{mode}{The audio format of the data in the buffer.}
	\SysParm{r2}{const void *}{chunk}{The location of the buffer in memory to enqueue.}
	\SysParm{r3}{int}{chunkbytes}{The number of bytes in the buffer to enqueue.}
	\SysParm{r4}{int}{maxbuf}{The maximum number of bytes to enqueue in the kernel.}
	\SysRetn{int}{0 on success, or a negative error number.}
}

\SysCall{input}{0x50}
{
	Reads input events from the system into the given buffer.
	Returns how many events were filled in the buffer, or a negative error number.
	
	The first byte of any event is a character indicating its type. Presently, only the following are defined:
	
	\begin{tabular}{l l l}
	First byte & Total bytes & Event type \\
	\Const{'A'} (\Const{0x41}) & 4 & Player 1 digital gamepad input \\
	\Const{'B'} (\Const{0x42}) & 4 & Player 2 digital gamepad input \\
	\Const{'C'} (\Const{0x43}) & 4 & Player 3 digital gamepad input \\
	\Const{'D'} (\Const{0x44}) & 4 & Player 4 digital gamepad input
	\end{tabular}	
	\\
	The input events defined currently follow the format below:
	
	\begin{tabular}{l l l}
	Offset & Size & Field \\
	0 & 1 & Type \\
	1 & 1 & Unused \\
	2 & 2 & Buttons Pressed
	\end{tabular}
	\\
	The "buttons pressed" field is a bitmask where a 1-bit is a pressed button and a 0-bit is a released button.
	The buttons use the following indexes:
	
	\begin{tabular}{l l l}
	Button & Index & Bitmask \\
	Up     &  \Const{0}    & \Const{0x0001} \\
	Left   &  \Const{1}    & \Const{0x0002} \\
	Down   &  \Const{2}    & \Const{0x0004} \\
	Right  &  \Const{3}    & \Const{0x0008} \\
	A      &  \Const{4}    & \Const{0x0010} \\
	B      &  \Const{5}    & \Const{0x0020} \\
	C      &  \Const{6}    & \Const{0x0040} \\
	X      &  \Const{7}    & \Const{0x0080} \\
	Y      &  \Const{8}    & \Const{0x0100} \\
	Z      &  \Const{9}    & \Const{0x0200} \\ 
	Start  & \Const{10}    & \Const{0x0400} \\
	Mode   & \Const{11}    & \Const{0x0800} \\ 
	\end{tabular}
	\\
	This system-call will typically return an input event per frame per controller port. The buffer should be at least 4-byte-aligned.
}
{
	\SysParm{r1}{{\Undie}sc{\Undie}input{\Undie}t *}{buffer{\Undie}ptr}{The location of the buffer to store the input events.}
	\SysParm{r2}{int}{bytes{\Undie}per{\Undie}event}{The number of bytes in each element of the buffer.}
	\SysParm{r3}{int}{bytes{\Undie}max}{The total size of the buffer in bytes.}
	\SysRetn{int}{The number of events filled or a negative error number.}
}

\subsection{Data access}

\SysCall{disk{\Undie}read2k}{0x91}
{
	Reads a 2048-byte sector from the disk into the given buffer.
	The sector number is given in units of 2KByte, i.e. not a byte-offset.
	Returns the number of bytes read (2048) on success or a negative error number.
	May return \Const{-{\Undie}SC{\Undie}EAGAIN} if the operation has started and will finish later.
}
{
	\SysParm{r1}{int}{sector{\Undie}num}{Which sector to load from the disk, in units of 2048 bytes.}
	\SysParm{r2}{void *}{buf2k}{The location in memory to store the data being read.}
	\SysRetn{int}{The number of bytes read, 2048, on success, or a negative error number.}
}

\SysCall{disk{\Undie}write2k}{0x92}
{
	Writes a 2048-byte sector to the disk from the given buffer.
	The sector number is given in units of 2KByte, i.e. not a byte-offset.
	Returns the number of bytes written (2048) on success or a negative error number.
	May return \Const{-{\Undie}SC{\Undie}EAGAIN} if the operation has started and will finish later.
}
{
	\SysParm{r1}{int}{sector{\Undie}num}{Which sector to write on the disk, in units of 2048 bytes.}
	\SysParm{r2}{const void *}{buf2k}{The data in memory to store onto the disk.}
	\SysRetn{int}{The number of bytes written, 2048, on success, or a negative error number.}
}

\SysCall{nvm{\Undie}save}{0x81}
{
	Writes data to the configured nonvolatile memory record, overwriting any previous data.
	The contents should be in the buffer at "data", of length "len".
	Writes are atomic and update the whole record each time. No partial writes are possible.
	Returns the number of bytes written on success or a negative error number.
}
{
	\SysParm{r1}{const void *}{data}{The data in memory to store to nonvolatile memory.}
	\SysParm{r2}{int}{len}{How many bytes to store.}
	\SysRetn{int}{The number of bytes written or a negative error number.}
}

\SysCall{nvm{\Undie}load}{0x82}
{
	Reads from the configured nonvolatile memory record into the given buffer.
	The buffer to place the results in is at "buf", of length "len".
	Reads are protected by SHA256; corruption will result in the file being lost (\Const{-{\Undie}SC{\Undie}ENOENT}).
	Returns the number of bytes read on success or a negative error number.
}
{
	\SysParm{r1}{void *}{buf}{The location in memory to put the data from nonvolatile memory.}
	\SysParm{r2}{int}{len}{How many bytes to load.}
	\SysRetn{int}{The number of bytes read or a negative error number.}
}

\SysCall{read}{0x11}
{
	Reads from a file. Writes up to "len" bytes into the buffer at "buf".
	fd will generally be 0 (\Const{STDIN{\Undie}FILENO}), as games aren't allowed to open more kernel-level files.
	Returns the number of bytes read if any are successfully read.
	Returns a negative error number if an error occurs before any bytes are read.
	Returns 0 to indicate that the end-of-file has been reached.
}
{
	\SysParm{r1}{int}{fd}{Which kernel-level file descriptor to read from, probably 0.}
	\SysParm{r2}{void *}{buf}{The location in memory to put the data once read.}
	\SysParm{r3}{int}{len}{How many bytes to read.}
	\SysRetn{int}{The number of bytes read or a negative error number.}
}

\SysCall{write}{0x12}
{
	Writes to a file. Reads up to "len" bytes from the buffer at "buf".
	fd will generally be 1 (\Const{STDOUT{\Undie}FILENO}) or 2 (\Const{STDERR{\Undie}FILENO}), as games aren't allowed to open more kernel-level files.
	Returns the number of bytes written if any were successfully written.
	Returns a negative error number if an error occurs before any bytes are written.
}
{
	\SysParm{r1}{int}{fd}{Which kernel-level file descriptor to write to, probably 1 or 2.}
	\SysParm{r2}{const void *}{buf}{The data in memory to write to the file.}
	\SysParm{r3}{int}{len}{How many bytes to write.}
	\SysRetn{int}{The number of bytes written or a negative error number.}
}

\subsection{Process setup}


\SysCall{mem{\Undie}sbrk}{0x40}
{
	Changes the size of the calling process's memory space, adding "req" new bytes.
	(The memory space cannot ever be reduced, except by calling exec() with a smaller image.)
	The new bytes are appended at the old end-of-process address. The OLD end-of-process is returned.
	A negative error number is returned on failure (probably, \Const{-{\Undie}SC{\Undie}ENOMEM}).
}
{
	\SysParm{r1}{int}{req}{The number of bytes to add to the process memory space.}
	\SysRetn{int}{The previous size of the process, before adding the new bytes. Or, a negative error number.}
}

\SysCall{sig{\Undie}mask}{0x20}
{
	Alters the signal mask of the calling thread.
	Returns the \emph{old} mask.
	The following signal numbers are used by the kernel:
	
	\begin{tabular}{l l l}
	Signal Name & Number & Description \\
	\Const{{\Undie}SC{\Undie}SIGILL} &4 & Illegal operation, i.e. bad opcode\\
	\Const{{\Undie}SC{\Undie}SIGTRAP} &5 & Debug trap requested\\
	\Const{{\Undie}SC{\Undie}SIGKILL} &9 & Killed (cannot be blocked)\\
	\Const{{\Undie}SC{\Undie}SIGSEGV} &11 & Segmentation violation, i.e. out-of-bounds memory access\\
	\Const{{\Undie}SC{\Undie}SIGPIPE} &13 & Pipe broken when writing to kernel-level file\\
	\Const{{\Undie}SC{\Undie}SIGCHLD} &20 & Child process changed state (not applicable to game processes)
	\end{tabular}
	\\
	The signal mask can be altered in the following ways:
	
	\begin{tabular}{l l l}
	Operation & Value & Description\\
	\Const{{\Undie}SC{\Undie}SIGMASK{\Undie}BLOCK} & 0 & Blocks signals where the input bit is ``1".\\
	\Const{{\Undie}SC{\Undie}SIGMASK{\Undie}UNBLOCK} & 1 & Unblocks signals where the input bit is ``1".\\
	\Const{{\Undie}SC{\Undie}SIGMASK{\Undie}SETMASK} & 2 & Blocks signals if the input is ``1" and unblocks all others.
	\end{tabular}
}
{
	\SysParm{r1}{int}{how}{Which operation to perform on the signal mask.}
	\SysParm{r2}{int}{bits}{The input bitmask for the given operation.}
	\SysRetn{int}{The old signal mask, before the successful operation. Or a negative error number on failure.}
}

\SysCall{sig{\Undie}return}{0x22}
{
	Returns from a signal handler.
	
	The kernel saves the context that is interrupted when a signal is taken.
	It then masks all signals and restarts the process to address \MemAddr{4096}.
	This system-call returns to the interrupted context, including the old signal mask.
	
	As the kernel only saves a single context, signals are not reentrant.
	You probably do not want to unmask signals from inside a running signal handler.
}
{
	\SysParmNone
	\SysRetnDead
}

\SysCall{env{\Undie}save}{0x08}
{
	Appends the given data to the kernel's argument/environment buffer for the calling process.
	Subsequent calls append to the buffer; call with buf=len=0 to reset the buffer.
	This buffer is preserved across calls to exec() and mexec{\Undie}apply().
	Conventionally it should contain a series of NUL-terminated argument strings,
	then an extra NUL, then a series of NUL-terminated environment strings.
	Returns the number of bytes written or a negative error number.
}
{
	\SysParm{r1}{const void *}{buf}{The data in memory to store to the environment buffer.}
	\SysParm{r2}{int}{len}{How many bytes to store.}
	\SysRetn{int}{The number of bytes written or a negative error number.}	
}

\SysCall{env{\Undie}load}{0x09}
{
	Reads from the kernel's argument/environment buffer for the calling process.
	Writes the result into the calling process's user memory, usually after an exec() or mexec{\Undie}apply().
	Unlike {\Undie}sc{\Undie}env{\Undie}save, starts from the beginning each time it's called.
	Returns the number of bytes copied or a negative error number.
}
{
	\SysParm{r1}{void *}{buf}{The location in memory to put the data from the environment buffer.}
	\SysParm{r2}{int}{len}{How many bytes to load.}
	\SysRetn{int}{The number of bytes read or a negative error number.}
}

\SysCall{mexec{\Undie}append}{0xA1}
{
	Appends the given data to the kernel's pending memory image for the calling process.
	Subsequent calls append to the buffer; call with buf=len=0 to reset the buffer.
	The first 4KBytes appended are always inaccessible afterwards and can contain anything.
	The memory at address \MemAddr{0x1000} (+4KBytes in) is where execution starts after {\Undie}sc{\Undie}mexec{\Undie}apply.
	Returns the number of bytes appended on success.
	Returns a negative error number if a failure occurs before any bytes were appended.
}
{
	\SysParm{r1}{const void *}{buf}{The data in memory to append to the new memory space.}
	\SysParm{r2}{int}{len}{How many bytes to append.}
	\SysRetn{int}{The number of bytes appended or a negative error number.}	
}

\SysCall{mexec{\Undie}apply}{0xA2}
{
	Concludes an in-memory exec and replaces the current with the pending image.
	Does not return and does not fail.
	If there is no pending image, the caller exits as though killed by {\Undie}SC{\Undie}SIGSEGV.
}
{
	\SysParmNone
	\SysRetnDead
}

\SysCall{exit}{0x07}
{
	Generally obliterates the calling process.
	Optionally reports a signal that was responsible for its demise.
}
{
	\SysParm{r1}{int}{exitcode}{The return value to report to the parent process.}
	\SysParm{r2}{int}{signal}{The signal number responsible for the exit, if any. Zero otherwise.}
	\SysRetnDead
}

\pagebreak

\subsection{Error codes}
The following error codes may be returned by the kernel.
These values are defined as positive integers here.
When returned by a system-call, they are usually negated.
For example, a system-call which fails because there is not enough memory might then return -12.
\\
\\
\begin{tabular}{l l l}
\textbf{Error} & \textbf{Number} & \textbf{Description} \\
\Const{{\Undie}SC{\Undie}EPERM}       &  1 & Operation not permitted. \\
\Const{{\Undie}SC{\Undie}ENOENT}      &  2 & No such file or directory. \\
\Const{{\Undie}SC{\Undie}ESRCH}       &  3 & No such process. \\
\Const{{\Undie}SC{\Undie}EIO}         &  5 & I/O error. \\
\Const{{\Undie}SC{\Undie}ENXIO}       &  6 & No such device or address. \\
\Const{{\Undie}SC{\Undie}E2BIG}       &  7 & Argument list too long. \\
\Const{{\Undie}SC{\Undie}ENOEXEC}     &  8 & Executable file format error. \\
\Const{{\Undie}SC{\Undie}EBADF}       &  9 & Bad file descriptor. \\
\Const{{\Undie}SC{\Undie}ECHILD}      & 10 & No child processes. \\
\Const{{\Undie}SC{\Undie}EAGAIN}      & 11 & Resource unavailable, try again. \\
\Const{{\Undie}SC{\Undie}ENOMEM}      & 12 & Not enough space. \\
\Const{{\Undie}SC{\Undie}EFAULT}      & 14 & Bad address. \\
\Const{{\Undie}SC{\Undie}EBUSY}       & 16 & Device or resource busy. \\
\Const{{\Undie}SC{\Undie}EEXIST}      & 17 & File exists. \\
\Const{{\Undie}SC{\Undie}ENOTDIR}     & 20 & Not a directory or a symbolic link to a directory. \\
\Const{{\Undie}SC{\Undie}EISDIR}      & 21 & Is a directory. \\
\Const{{\Undie}SC{\Undie}EINVAL}      & 22 & Invalid argument. \\
\Const{{\Undie}SC{\Undie}ENFILE}      & 23 & Too many files open in system. \\
\Const{{\Undie}SC{\Undie}EMFILE}      & 24 & File descriptor value too large. \\
\Const{{\Undie}SC{\Undie}ENOTTY}      & 25 & Inappropriate I/O control operation. \\
\Const{{\Undie}SC{\Undie}EFBIG}       & 27 & File too large. \\
\Const{{\Undie}SC{\Undie}ENOSPC}      & 28 & No space left on device. \\
\Const{{\Undie}SC{\Undie}ESPIPE}      & 29 & Invalid seek. \\
\Const{{\Undie}SC{\Undie}EPIPE}       & 32 & Broken pipe. \\
\Const{{\Undie}SC{\Undie}EDEADLOCK}   & 35 & Resource deadlock would occur. \\
\Const{{\Undie}SC{\Undie}ENAMETOOLONG}& 36 & Filename too long. \\
\Const{{\Undie}SC{\Undie}ENOSYS}      & 38 & Functionality not supported. \\
\Const{{\Undie}SC{\Undie}ENOTEMPTY}   & 39 & Directory not empty. \\
\Const{{\Undie}SC{\Undie}ELOOP}       & 40 & Too many levels of symbolic links. \\
\end{tabular}

\subsection{System calls by number}
The following table lists all system-calls usable by a game, sorted by call number.
\\
\\
\begin{tabular}{l l}
Number & Name\\
\Const{0x00} &\VarName{{\Undie}sc{\Undie}none}\\
\Const{0x01} &\VarName{{\Undie}sc{\Undie}pause}\\
\Const{0x02} &\VarName{{\Undie}sc{\Undie}getticks}\\
\Const{0x07} &\VarName{{\Undie}sc{\Undie}exit}\\
\Const{0x08} &\VarName{{\Undie}sc{\Undie}env{\Undie}save}\\
\Const{0x09} &\VarName{{\Undie}sc{\Undie}env{\Undie}load}\\
\Const{0x11} &\VarName{{\Undie}sc{\Undie}read}\\
\Const{0x12} &\VarName{{\Undie}sc{\Undie}write}\\
\Const{0x20} &\VarName{{\Undie}sc{\Undie}sig{\Undie}mask}\\
\Const{0x22} &\VarName{{\Undie}sc{\Undie}sig{\Undie}return}\\
\Const{0x30} &\VarName{{\Undie}sc{\Undie}gfx{\Undie}flip}\\
\Const{0x40} &\VarName{{\Undie}sc{\Undie}mem{\Undie}sbrk}\\
\Const{0x50} &\VarName{{\Undie}sc{\Undie}input}\\
\Const{0x60} &\VarName{{\Undie}sc{\Undie}snd{\Undie}play}\\
\Const{0x81} &\VarName{{\Undie}sc{\Undie}nvm{\Undie}save}\\
\Const{0x82} &\VarName{{\Undie}sc{\Undie}nvm{\Undie}load}\\
\Const{0x91} &\VarName{{\Undie}sc{\Undie}disk{\Undie}read2k}\\
\Const{0x92} &\VarName{{\Undie}sc{\Undie}disk{\Undie}write2k}\\
\Const{0xA1} &\VarName{{\Undie}sc{\Undie}mexec{\Undie}append}\\
\Const{0xA2} &\VarName{{\Undie}sc{\Undie}mexec{\Undie}apply}\\
\Const{0xFF} &\VarName{{\Undie}sc{\Undie}version}
\end{tabular}

\section{The C SDK}
The C SDK is an easy way to start writing programs for Neki32.
It provides a runtime environment that behaves like a POSIX-compatible system, such as Linux or FreeBSD.
The SDK includes the following parts.
\subsection{Compiler Wrappers}
The compiler wrappers help to invoke GCC or LLVM with the right options for building a Neki32 executable.
You must have an appropriate GCC or LLVM compiler installed, of course. It needs to be able to target the ARMv5TE architecture.
\subsection{C Runtime}
The C Runtime is what initially starts running when the Neki32 kernel loads your program.
It requests memory for all your variables, unmasks signals, and calls your main function.
It also contains the linker configuration, so the linker can make an executable in the right format (a flat 0-based binary).
\subsection{Picolibc}
This is a port of PicoLibC to the Neki32. PicoLibC is a portable C Standard Library. It provides functions like printf and strcpy.
\subsection{PVMK OS library}
The OS Library is a link between the PicoLibC code and the system-calls available on the Neki32.
It handles some things that aren't implemented in the kernel itself.

For example, the system-call interface on Neki32 provides block-level access to sectors from the game card.
The system doesn't care what kind of filesystem is on the card.
So, when your application calls fopen(), someone has to go understand the filesystem on the card and find the file you wanted.
The code is in this library, so you can open/read/close like normal.
\subsection{Updates Package}
This is the official Neki32 system-update package from Nekisoft.
This can be included on game media to ensure that players have the latest system software.
Note that a license is required to distribute this - you must adhere to our software quality and marketing guidelines.
See the licensing section for more information.
\subsection{SDL System-Call Shims}
This is an implementation of some system-calls on top of the SDL2 library.
Using this, instead of the real system-call library, you can build and test your code on a desktop Linux machine.
Then, you could compile the same application for Neki32 with minimal changes.

\section{Examples}
\subsection{Just Assembly}
\subsection{Assembly and some Data}
\subsection{Assembly in a Filesystem}
\subsection{Adding some Freestanding C}
\subsection{Using the C SDK Instead}

\end{document}