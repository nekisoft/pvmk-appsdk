%intro.latex
%Introductory document for Neki32 developers
%Bryan E. Topp <betopp@betopp.com> 2024

\documentclass[12pt]{article}

\usepackage{geometry}
\usepackage{comment}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\hypersetup{linktoc=all}

%In case we want fancy type like the LaTeX logo
\def\Neki32{{Neki32}}

%For underscores in variable names
\def\Undie{{\underline{\hspace{0.5em}}}}

%Formatting of memory addresses, registers, etc
\newcommand{\MemAddr}[1]{\texttt{#1}}
\newcommand{\Reg}[1]{\texttt{#1}}
\newcommand{\Const}[1]{\texttt{#1}}
\newcommand{\Instr}[1]{\texttt{#1}}

\begin{document}

\author{Bryan E. Topp}
\title{\includegraphics[width=10cm]{logo.png}\\Introduction to \Neki32 Software Development}
\date{16 September 2024}
\maketitle

\tableofcontents

\pagebreak

\section*{Conventions}

Numbers are in decimal (base-10) unless otherwise stated.\\
Numbers beginning with a \Const{0x} prefix are hexadecimal (base-16).

\section{Introduction}

Thank you for your interest in developing software for \Neki32!

\subsection{What is \Neki32?}

\Neki32 is a 32-bit game console that delivers a fast no-nonsense experience to both gamers and game developers.
The system runs on an ARM9 CPU clocked at 300MHz. Up to 24MBytes of memory is available for the game process.
Software-rendering is used to produce bitmapped graphics and digital sound.

An operating system hides details of the hardware.
The application format and interface is kept to a minimum.

The \Neki32 console itself is powered by USB-C.
It outputs audio and video to an HDMI TV.
Games are distributed on read-only SD cards. 
There are four controller ports, compatible with Genesis and Mega-Drive controllers.

(Picture of the console goes here.)

\pagebreak

\subsection{Technical Specifications}
\begin{itemize}
	\item Power input:
	\begin{itemize}
		\item Connector: USB-C compatible\footnote{The \Neki32 console is not USB\texttrademark{}-certified but should work with any USB-C power supply.}
		\item Voltage: \(5V \pm 10 \% \)
		\item Current: \(\leq 100mA\)
	\end{itemize}
	\item A/V output:
	\begin{itemize}
		\item Connector: HDMI compatible\footnote{It is is also not HDMI\texttrademark{}-certified but should work with any HDMI television.}
		\item Resolution: 640x480, or 320x240 with pixel-doubling
		\item Refresh rate: 60Hz
		\item Aspect ratio: 4:3
		\item Color depth: 16 bits per pixel, RGB565
		\item Audio format: 48KHz 16-bit stereo LPCM
	\end{itemize}
	\item User inputs:
	\begin{itemize}
		\item Connector: 9-pin D-Sub (male) x4
		\item Layout: 8-way directional pad, 6 face buttons, 2 menu buttons
		\item Protocol: Mega-Drive compatible\footnote{Mega-Drive\texttrademark{} is owned by Sega and used without permission. They are unaffiliated with us.}
	\end{itemize}
	\item Game media:
	\begin{itemize}
		\item Connector: SD/MMC card (full-size)
		\item Capacity: 16MBytes to 2TBytes
		\item Format: El-Torito bootable image, platform \Const{0x92}
	\end{itemize}
\end{itemize}

\pagebreak

\subsection{Overview of a Game}

A Neki32 game is quite simple. It is an SD card containing a program to run and possibly other data. Very little is necessary to get code running.

The card is read-only and formatted much like an optical disc.
It contains an El Torito boot record for platform \Const{0x92}.
The El Torito boot record points at the executable file for the game.

The game executable is a flat, 0-mapped binary image of the game's initial memory content.
For example, if the game executable is 3MBytes in size, the system will load it into virtual memory addresses \MemAddr{0} to \MemAddr{3145727}.
The zero page, afterward, is inaccessible. Memory from addres \MemAddr{0} to \MemAddr{4095} always faults.
A small magic number is placed here instead.

The game starts execution at address \MemAddr{4096}, the first accessible address.
All registers are zeroed on entry.
The process starts in ARM mode but may switch to Thumb mode at its choice.

System-calls can be made using a \Instr{svc 0x92} instruction.
The call number is placed in \Reg{r0}, while parameters are placed in \Reg{r1} through \Reg{r5}.
Return values are left in \Reg{r0} after the call is performed.

Exceptions are delivered to the game process as a signal.
Signals are initially blocked. An exception causing a blocked signal will terminate the process.
A signal can be unblocked and handled instead.
In this case, it causes the process to restart to address \MemAddr{4096} with the signal number in \Reg{r0}. A system-call is used to return from the signal.

\section{The boot process}
The boot process treats the game card like an optical disc - it is read-only and organized in naturally-aligned 2048-byte sectors.
Sector \MemAddr{0} contains bytes \MemAddr{0} to \MemAddr{2047}, sector \MemAddr{1} contains bytes \MemAddr{2048} to \MemAddr{4095}, and so on.

\subsection{The beginning of the media}

The system first reads sectors \Const{0x10} and \Const{0x11}.
Sector \Const{0x10} always contains the ISO9660 Primary Volume Descriptor, describing the game media.
The ISO9660 Primary Volume Descriptor gives the name of the media, in a \Const{32}-byte field at offset \Const{40}.
If this is present, not entirely whitespace, and not \Const{CDROM} or \Const{cdrom}, it is taken to be the game's name.

Sector \Const{0x11} always contains the El Torito Boot Volume Descriptor, describing the boot information.
The El Torito Boot Volume Descriptor, from sector \Const{0x11}, is used to locate an El Torito Boot Catalog.
The El Torito Boot Volume Descriptor must contain the magic value \Const{EL TORITO SPECIFICATION} at offset \MemAddr{7}.
It also contains the sector number of the El Torito Boot Catalog, as a 32-bit little-endian number at offset \MemAddr{0x47}.
This is taken to be in units of \Const{2048} bytes, from the beginning of the game media.

\subsection{The boot catalog}
The system reads the El Torito Boot Catalog from the sector number given in the El Torito Boot Volume Descriptor.
Only one sector is read, even though El Torito allows for larger boot catalogs.
The Boot Catalog consists of \Const{32}-byte entries, naturally-aligned.
The first entry must start with the following one-byte magic values:

\begin{tabular}{ r r }
Offset & Value \\
\MemAddr{0x00} & \Const{0x01} \\
\MemAddr{0x1E} & \Const{0x55} \\
\MemAddr{0x1F} & \Const{0xAA}
\end{tabular}

Following this, entries begin with a one-byte value specifying their type, a single byte at offset \MemAddr{0}.

Types \Const{0x01}, \Const{0x90}, or \Const{0x91} begin a section of the Boot Catalog, and contain a Platform ID for entries that follow.
The platform ID is located at offset \MemAddr{1} in such an entry.
The platform ID for a \Neki32 application is \Const{0x92}. A boot entry following this platform will contain game code.
The platform ID for a \Neki32 system-update bundle is \Const{0x22}. A boot entry following this platform will contain packaged system-update data from Nekisoft.

Type \Const{0x88} indicates a bootable entry.
The platform ID of the bootable entry is given in a preceding section entry.
The length of the bootable payload is given as a 2-byte little-endian value at offset \MemAddr{6}. The length is given in units of \Const{512} bytes.
The location of the bootable payload is given as a 4-byte little-endian value at offset \MemAddr{8}. The location is given in units of \Const{2048} bytes, relative to the beginning of the game media.

The first bootable entry of platform ID \Const{0x92} is taken to be the game executable to boot.
The first bootable entry of platform ID \Const{0x22} is taken to be the system update package to examine, if any.
The format of the system update package is not described here.
It should be obtained from Nekisoft and included verbatim.

\subsection{The game executable}

Once the location of the game executable is found in the El Torito Boot Catalog, the system begins to load it.
The game executable is loaded into a new virtual memory space, by itself.
The virtual memory space starts at address \MemAddr{0} and extends to the size specified in the El Torito Boot Catalog.
As the size is given as a 16-bit number in units of \Const{512} bytes, up to 32MBytes could be specified.
However, a game on Neki32 is limited to 24MBytes of memory at any time.

After loading, the zero page is checked for an appropriate magic number.
The first eight bytes should be \Const{NNEARM32}.
The second eight bytes should be the entry point as a 64-bit little-endian value.
This value must always be \MemAddr{0x1000}.

Once the game executable is loaded, the game process starts executing it from \MemAddr{0x1000}, with all registers zeroed.
The game must then make its first system-call with \Reg{r0} set to \Const{0xFF} and \Reg{r1} set to \Const{1} to declare the version of the system ABI it expects.

\subsection{Failures}

If any of these steps encounters a missing magic-number or a failure to read the game media, the booting process stops.
Instead of launching the game, the console will drop to its system menu.
The system menu allows users to see the data saved on their console or turn it off.

\section{The instruction set}

The game executable runs in user-mode on an ARMv5TE processor, including both ARM and Thumb modes.
The system will always start executing the game in ARM mode, with the program counter at \MemAddr{0x1000}.
Thumb interworking instructions may be used to transfer into and out of Thumb mode.

No floating-point instructions are available.
Floating-point emulation works well enough to run Quake, at least, if you really want that.

The \Instr{svc 0x92} instruction is used to trigger system-calls. Other \Instr{svc} instructions should not be used.

\section{System calls}

System-calls are used to access hardware features in a backward- and forward-compatible way.

To run a system call, place its inputs in registers. The call number is passed in register \Reg{r0}.
Parameters, if any, are passed in registers \Reg{r1} to \Reg{r5}. Then, use the \Instr{svc 0x92} instruction.
The return value is stored in \Reg{r0} after the call finishes.

Typically, system-calls will return a negative error number if they fail, or a nonnegative value on success.

System-calls are nonblocking. If a long-term operation is started, its system-call returns with \Const{-{\Undie}SC{\Undie}EAGAIN}.
The call should then be repeated until it completes, returning a successful result.

\begin{comment}

// _sc_none //
//Does nothing.
SYSCALL_DECL void _sc_none(void)
	#define  _SC_NONE_N 0x00
	{ _SC(_SC_NONE_N, 0, 0, 0, 0, 0); }

// _sc_pause //
//Waits until anything happens to the calling process, or has happened since the last call returned.
//This is the only way to actually "block" your process at the kernel level.
//When we say "anything happens", it means "anything relating to a system-call you previously made".
//So, idiomatically, you would write: while(1) { try_my_thing(); if(it_finished()) { break; } else { _sc_pause(); } }
SYSCALL_DECL void _sc_pause(void)
	#define  _SC_PAUSE_N 0x01
	{ _SC(_SC_PAUSE_N, 0, 0, 0, 0, 0); }

// _sc_getticks //
//Returns the number of milliseconds since the system was booted.
//Does not fail.
SYSCALL_DECL int _sc_getticks(void)
	#define _SC_GETTICKS_N 0x02
	{ return _SC(_SC_GETTICKS_N, 0, 0, 0, 0, 0); }

// _sc_exit //
//Generally obliterates the calling process.
//Optionally reports a signal that was responsible for its demise.
SYSCALL_DECL _NORETURN void _sc_exit(int exitcode, int signal)
	#define  _SC_EXIT_N 0x07
	{ _SC(_SC_EXIT_N, exitcode, signal, 0, 0, 0); _DONTRETURN; }

// _sc_env_save //
//Appends the given data to the kernel's argument/environment buffer for the calling process.
//Subsequent calls append to the buffer; call with buf=len=0 to reset the buffer.
//This buffer is preserved across calls to exec() and mexec_apply().
//Conventionally it should contain a series of NUL-terminated argument strings,
//then an extra NUL, then a series of NUL-terminated environment strings.
//Returns the number of bytes written or a negative error number.
SYSCALL_DECL int _sc_env_save(const void *buf, int len)
	#define _SC_ENV_SAVE_N 0x08
	{ return _SC(_SC_ENV_SAVE_N, buf, len, 0, 0, 0); }

// _sc_env_load //
//Reads from the kernel's argument/environment buffer for the calling process.
//Writes the result into the calling process's user memory, usually after an exec() or mexec_apply().
//Unlike _sc_env_save, starts from the beginning each time it's called.
//Returns the number of bytes copied or a negative error number.
SYSCALL_DECL int _sc_env_load(void *buf, int len)
	#define _SC_ENV_LOAD_N 0x09
	{ return _SC(_SC_ENV_LOAD_N, buf, len, 0, 0, 0); }

// _sc_read //
//Reads from a file. Writes up to "len" bytes into the buffer at "buf".
//fd will generally be 0 (STDIN_FILENO), as games aren't allowed to open more kernel-level files.
//Returns the number of bytes read if any are successfully read.
//Returns a negative error number if an error occurs before any bytes are read.
//Returns 0 to indicate that the end-of-file has been reached.
SYSCALL_DECL int _sc_read(int fd, void *buf, int len)
	#define _SC_READ_N 0x11
	{ return _SC(_SC_READ_N, fd, buf, len, 0, 0); }

// _sc_write //
//Writes to a file. Reads up to "len" bytes from the buffer at "buf".
//fd will generally be 1 (STDOUT_FILENO) or 2 (STDERR_FILENO), as games aren't allowed to open more kernel-level files.
//Returns the number of bytes written if any were successfully written.
//Returns a negative error number if an error occurs before any bytes are written.
SYSCALL_DECL int _sc_write(int fd, const void *buf, int len)
	#define _SC_WRITE_N 0x12
	{ return _SC(_SC_WRITE_N, fd, buf, len, 0, 0); }

//Signal numbers defined in the kernel
#define _SC_SIGZERO 0
#define _SC_SIGHUP 1
#define _SC_SIGINT 2
#define _SC_SIGQUIT 3
#define _SC_SIGILL 4
#define _SC_SIGTRAP 5
#define _SC_SIGABRT 6
#define _SC_SIGEMT 7
#define _SC_SIGFPE 8
#define _SC_SIGKILL 9
#define _SC_SIGBUS 10
#define _SC_SIGSEGV 11
#define _SC_SIGSYS 12
#define _SC_SIGPIPE 13
#define _SC_SIGALRM 14
#define _SC_SIGTERM 15
#define _SC_SIGURG 16
#define _SC_SIGSTOP 17
#define _SC_SIGTSTP 18
#define _SC_SIGCONT 19
#define _SC_SIGCHLD 20
#define _SC_SIGTTIN 21
#define _SC_SIGTTOU 22
#define _SC_SIGXCPU 23
#define _SC_SIGXFSZ 24
#define _SC_SIGVTALRM 25
#define _SC_SIGPROF 26
#define _SC_SIGWINCH 27
#define _SC_SIGINFO 28
#define _SC_SIGUSR1 29
#define _SC_SIGUSR2 30

//Ways to alter the signal mask of a thread.
#define _SC_SIGMASK_BLOCK 0
#define _SC_SIGMASK_UNBLOCK 1
#define _SC_SIGMASK_SETMASK 2

// _sc_sig_mask //
//Alters the signal mask of the calling thread.
//Returns the OLD mask.
SYSCALL_DECL int _sc_sig_mask(int how, int bits)
	#define _SC_SIG_MASK_N 0x20
	{ return _SC(_SC_SIG_MASK_N, how, bits, 0, 0, 0); }

// _sc_sig_return //
//Returns from a signal handler.
SYSCALL_DECL _NORETURN void _sc_sig_return(void)
	#define  _SC_SIG_RETURN_N 0x22
	{ _SC(_SC_SIG_RETURN_N, 0, 0, 0, 0, 0); _DONTRETURN; }
	
// _sc_mem_sbrk //
//Changes the size of the calling process's memory space, adding "req" new bytes.
//(The memory space cannot ever be reduced, except by calling exec() with a smaller image.)
//The new bytes are appended at the old end-of-process address. The OLD end-of-process is returned.
//A negative error number is returned on failure (probably, -_SC_ENOMEM).
SYSCALL_DECL int _sc_mem_sbrk(int req)
	#define _SC_MEM_SBRK_N 0x40
	{ return _SC(_SC_MEM_SBRK_N, req, 0, 0, 0, 0); }
	
//Graphics modes that are used with _sc_gfx_flip.
#define _SC_GFX_MODE_TEXT          0 //No framebuffer supplied; kernel text mode only
#define _SC_GFX_MODE_VGA_16BPP     1 //640x480@60Hz RGB565, 1280 bytes per line
#define _SC_GFX_MODE_320X240_16BPP 2 //320x240@60Hz RGB565, 640 bytes per line
#define _SC_GFX_MODE_MAX           3 //Number of modes supported; mode parameter must be less than this

// _sc_gfx_flip //
//Enqueues a change of the system front-buffer to the given buffer.
//Only takes effect during vertical blanking.
//If mode is 0 (text), buffer must be NULL.
//If mode is nonzero, buffer must be given and large enough for one framebuffer.
//Returns the address of the image currently displayed.
//Can return 0 if the currently-displayed image belongs to another process.
//Returns a negative error number on failure (if nothing was enqueued).
SYSCALL_DECL int _sc_gfx_flip(int mode, const void *buffer)
	#define _SC_GFX_FLIP_N 0x30
	{ return _SC(_SC_GFX_FLIP_N, mode, buffer, 0, 0, 0); }

//Audio modes that are used with _sc_snd_play.
#define _SC_SND_MODE_SILENT      0 //Stops all sounds
#define _SC_SND_MODE_48K_16B_2C  1 //Linear PCM, 48KHz, 16-bit stereo, native byte order, left-then-right
#define _SC_SND_MODE_MAX         2 //Number of modes supported; mode parameter must be less than this

// _sc_snd_play //
//Enqueues audio samples for output.
//Returns 0 on success, or a negative error number.
//Returns -EAGAIN if there wasn't enough space for the chunk - audio buffer is already full.
//The "maxbuf" parameter limits how many bytes will be buffered by the system before -EAGAIN is returned.
//Does not consume partial chunks - the chunk is either enqueued entirely or rejected.
SYSCALL_DECL int _sc_snd_play(int mode, const void *chunk, int chunkbytes, int maxbuf)
	#define _SC_SND_PLAY_N 0x60
	{ return _SC(_SC_SND_PLAY_N, mode, chunk, chunkbytes, maxbuf, 0); }

//Button masks sent in inputs
#define _SC_BTNIDX_UP      0
#define _SC_BTNIDX_LEFT    1
#define _SC_BTNIDX_DOWN    2
#define _SC_BTNIDX_RIGHT   3
#define _SC_BTNIDX_A       4
#define _SC_BTNIDX_B       5
#define _SC_BTNIDX_C       6
#define _SC_BTNIDX_X       7
#define _SC_BTNIDX_Y       8
#define _SC_BTNIDX_Z       9
#define _SC_BTNIDX_START  10
#define _SC_BTNIDX_MODE   11

#define _SC_BTNBIT_UP      (1u << _SC_BTNIDX_UP)
#define _SC_BTNBIT_LEFT    (1u << _SC_BTNIDX_LEFT)
#define _SC_BTNBIT_DOWN    (1u << _SC_BTNIDX_DOWN)
#define _SC_BTNBIT_RIGHT   (1u << _SC_BTNIDX_RIGHT)
#define _SC_BTNBIT_A       (1u << _SC_BTNIDX_A)
#define _SC_BTNBIT_B       (1u << _SC_BTNIDX_B)
#define _SC_BTNBIT_C       (1u << _SC_BTNIDX_C)
#define _SC_BTNBIT_X       (1u << _SC_BTNIDX_X)
#define _SC_BTNBIT_Y       (1u << _SC_BTNIDX_Y)
#define _SC_BTNBIT_Z       (1u << _SC_BTNIDX_Z)
#define _SC_BTNBIT_START   (1u << _SC_BTNIDX_START)
#define _SC_BTNBIT_MODE    (1u << _SC_BTNIDX_MODE)

//Format of an input event.
typedef struct _sc_input_s
{
	//Common event header
	char format; //Format of the report - 'A' for first player's buttons, 'B' 'C' 'D' for further players
	char flags; //Unused for the moment
	short buttons; //Buttons depressed, as in _SC_BUTTONS macros
} _sc_input_t __attribute__((aligned(4)));

// _sc_input //
//Reads input events, writing them into the given buffer.
//Returns the number of events filled, or a negative error number.
SYSCALL_DECL int _sc_input(_sc_input_t *buffer_ptr, int bytes_per_event, int bytes_max)
	#define _SC_INPUT_N 0x50
	{ return _SC(_SC_INPUT_N, buffer_ptr, bytes_per_event, bytes_max, 0, 0); }

// _sc_nvm_save //
//Writes data to the configured nonvolatile memory record, overwriting any previous data.
//The contents should be in the buffer at "data", of length "len".
//Writes are atomic and update the whole record each time. No partial writes are possible.
//Returns the number of bytes written on success or a negative error number.
SYSCALL_DECL int _sc_nvm_save(const void *data, int len)
	#define _SC_NVM_SAVE_N 0x81
	{ return _SC(_SC_NVM_SAVE_N, data, len, 0, 0, 0); }

// _sc_nvm_load //
//Reads from the configured nonvolatile memory record into the given buffer.
//The buffer to place the results in is at "buf", of length "len".
//Reads are protected by SHA256; corruption will result in the file being lost (-_SC_ENOENT).
//Returns the number of bytes read on success or a negative error number.
SYSCALL_DECL int _sc_nvm_load(void *buf, int len)
	#define _SC_NVM_LOAD_N 0x82
	{ return _SC(_SC_NVM_LOAD_N, buf, len, 0, 0, 0); }
	
// _sc_disk_read2k //
//Reads a 2048-byte sector from the disk into the given buffer.
//The sector number is given in units of 2KByte, i.e. not a byte-offset.
//Returns the number of bytes read (2048) on success or a negative error number.
//May return -_SC_EAGAIN if the operation has started and will finish later.
SYSCALL_DECL int _sc_disk_read2k(int sector_num, void *buf2k)
	#define _SC_DISK_READ2K_N 0x91
	{ return _SC(_SC_DISK_READ2K_N, sector_num, buf2k, 0, 0, 0); }

// _sc_disk_write2k //
//Writes a 2048-byte sector to the disk from the given buffer.
//The sector number is given in units of 2KByte, i.e. not a byte-offset.
//Returns the number of bytes written (2048) on success or a negative error number.
//May return -_SC_EAGAIN if the operation has started and will finish later.
SYSCALL_DECL int _sc_disk_write2k(int sector_num, const void *buf2k)
	#define _SC_DISK_WRITE2K_N 0x92
	{ return _SC(_SC_DISK_WRITE2K_N, sector_num, buf2k, 0, 0, 0); }
	
// _sc_mexec_append //
//Appends the given data to the kernel's pending memory image for the calling process.
//Subsequent calls append to the buffer; call with buf=len=0 to reset the buffer.
//The first 4KBytes appended are always inaccessible afterwards and can contain anything.
//The memory at address 0x1000 (+4KBytes in) is where execution starts after _sc_mexec_apply.
//Returns the number of bytes appended on success.
//Returns a negative error number if a failure occurs before any bytes were appended.
SYSCALL_DECL int _sc_mexec_append(const void *buf, int len)
	#define _SC_MEXEC_APPEND_N 0xA1
	{ return _SC(_SC_MEXEC_APPEND_N, buf, len, 0, 0, 0); }

// _sc_mexec_apply //
//Concludes an in-memory exec and replaces the current with the pending image.
//Does not return and does not fail.
//If there is no pending image, the caller exits as though killed by _SC_SIGSEGV.
SYSCALL_DECL _NORETURN void _sc_mexec_apply(void)
	#define  _SC_MEXEC_APPLY_N 0xA2
	{ _SC(_SC_MEXEC_APPLY_N, 0, 0, 0, 0, 0); _DONTRETURN; }
	
	
// _sc_version //
//Tells the kernel what version of the system-call interface is expected by the calling application.
//Returns the version of system-call interface that the kernel will then use.
//Returns a negative error number on failure - if the kernel and application are simply incompatible.
//System-call versions are set per-process. Currently only version "1" is supported.
SYSCALL_DECL int _sc_version(int version)
	#define _SC_VERSION_N 0xFF
	{ return _SC(_SC_VERSION_N, version, 0, 0, 0, 0); }

//Error numbers that may be returned by the kernel.
//They are defined positively here, but are returned as negative values by the kernel.
//These attempt to be the same as Linux error numbers, but please don't rely on that.
#define _SC_EPERM         1 //Operation not permitted.
#define _SC_ENOENT        2 //No such file or directory.
#define _SC_ESRCH         3 //No such process.
#define _SC_EINTR         4 //Interrupted function.
#define _SC_EIO           5 //I/O error.
#define _SC_ENXIO         6 //No such device or address.
#define _SC_E2BIG         7 //Argument list too long.
#define _SC_ENOEXEC       8 //Executable file format error.
#define _SC_EBADF         9 //Bad file descriptor.
#define _SC_ECHILD       10 //No child processes.
#define _SC_EAGAIN       11 //Resource unavailable, try again (may be the same value as EWOULDBLOCK).
#define _SC_EWOULDBLOCK  11 //Operation would block (may be the same value as EAGAIN).
#define _SC_ENOMEM       12 //Not enough space.
#define _SC_EACCES       13 //Permission denied.
#define _SC_EFAULT       14 //Bad address.
#define _SC_EBUSY        16 //Device or resource busy.
#define _SC_EEXIST       17 //File exists.
#define _SC_EXDEV        18 //Cross-device link.
#define _SC_ENODEV       19 //No such device.
#define _SC_ENOTDIR      20 //Not a directory or a symbolic link to a directory.
#define _SC_EISDIR       21 //Is a directory.
#define _SC_EINVAL       22 //Invalid argument.
#define _SC_ENFILE       23 //Too many files open in system.
#define _SC_EMFILE       24 //File descriptor value too large.
#define _SC_ENOTTY       25 //Inappropriate I/O control operation.
#define _SC_ETXTBSY      26 //Text file busy.
#define _SC_EFBIG        27 //File too large.
#define _SC_ENOSPC       28 //No space left on device.
#define _SC_ESPIPE       29 //Invalid seek.
#define _SC_EROFS        30 //Read-only file system.
#define _SC_EMLINK       31 //Too many links.
#define _SC_EPIPE        32 //Broken pipe.
#define _SC_EDOM         33 //Mathematics argument out of domain of function.
#define _SC_ERANGE       34 //Result too large.
#define _SC_EDEADLK      35 //Resource deadlock would occur.
#define _SC_EDEADLOCK    35 //Resource deadlock would occur.
#define _SC_ENAMETOOLONG 36 //Filename too long.
#define _SC_ENOLCK       37 //No locks available.
#define _SC_ENOSYS       38 //Functionality not supported.
#define _SC_ENOTEMPTY    39 //Directory not empty.
#define _SC_ELOOP        40 //Too many levels of symbolic links.
#define _SC_ENOMSG       42 //No message of the desired type.
#define _SC_EIDRM        43 //Identifier removed.

\end{comment}


\subsection{Game input/output}

\subsection{Data access}

\subsection{Process setup}


\section{The C SDK}
\subsection{C Runtime}
\subsection{PVMK OS library}
\subsection{Picolibc}

\section{Examples}
\subsection{Just Assembly}
\subsection{Assembly and some Data}
\subsection{Assembly in a Filesystem}
\subsection{Adding some Freestanding C}
\subsection{Using the C SDK Instead}

\end{document}