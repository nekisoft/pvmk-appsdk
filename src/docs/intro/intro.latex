%intro.latex
%Introductory document for Neki32 developers
%Bryan E. Topp <betopp@betopp.com> 2024
 
\documentclass[12pt]{article}

\usepackage{geometry}
\usepackage{comment}
\usepackage{courier}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\hypersetup{linktoc=all}

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true,linewidth=\textwidth}

%In case we want fancy type like the LaTeX logo
\def\Neki32{{Neki32}}

%For underscores in variable names
\def\Undie{{\_}}

%For lists
\def\BL{{\;} \\ \hspace{1em}{\;}{\textbullet}{\;}\hspace{0.5em}}

%Formatting of memory addresses, registers, etc
\newcommand{\MemAddr}[1]{\texttt{#1}}
\newcommand{\Reg}[1]{\texttt{#1}}
\newcommand{\Const}[1]{\texttt{#1}}
\newcommand{\Instr}[1]{\texttt{#1}}
\newcommand{\CType}[1]{\texttt{#1}}
\newcommand{\VarName}[1]{\texttt{#1}}
\newcommand{\PathName}[1]{\texttt{#1}}

%Formatting of system-call listings
\newcommand{\SysCall}[4]{\subsubsection{\texttt{{\Undie}sc{\Undie}#1}} Called with: \Reg{r0} = \Const{#2}. \\ #3 \begin{itemize} #4 \end{itemize}}
\newcommand{\SysParm}[4]{\item \Reg{#1} : \CType{#2} \VarName{#3}\\ #4 }
\newcommand{\SysRetn}[2]{\item Returns : \CType{#1} \\ #2}
\newcommand{\SysParmNone}[0]{\item No parameters. }
\newcommand{\SysRetnNone}[0]{\item No return value. }
\newcommand{\SysRetnDead}[0]{\item This call does not return. }


\begin{document}

\author{Nekisoft Pty Ltd}
\title{\includegraphics[width=10cm]{logo.png}\\The \Neki32 Software Development Manual}
\date{\today}
\maketitle
\pagebreak

\tableofcontents

\pagebreak

\section*{Preface}

Numbers are in decimal (base-10) unless otherwise stated.\\
Numbers beginning with a \Const{0x} prefix are hexadecimal (base-16).
\\
\\
\copyright2024 Nekisoft Pty Ltd\\
Australian Company Number 680 583 251

\section{Introduction}

Thank you for your interest in developing software for \Neki32!

\subsection{What is \Neki32?}

\Neki32 is a 32-bit game console that delivers a fast no-nonsense experience to both gamers and game developers.
The system runs on an ARM9 CPU clocked at 300MHz. Up to 24MBytes of memory is available for the game process.
Software-rendering is used to produce bitmapped graphics and digital sound.

An operating system hides details of the hardware.
The application format and interface is kept to a minimum.

The \Neki32 console itself is powered by USB-C.
It outputs audio and video to an HDMI TV.
Games are distributed on read-only SD cards. 
There are four controller ports, compatible with Genesis and Mega-Drive controllers.
There is 4MBytes of internal memory for savegames of 128KBytes per game.

(Picture of the console goes here.)

\pagebreak

\subsection{Technical Specifications}
\begin{itemize}
	\item Power input:
	\begin{itemize}
		\item Connector: USB-C compatible\footnote{The \Neki32 console is not USB\texttrademark{}-certified but should work with any USB-C power supply.}
		\item Voltage: \(5V \pm 10 \% \)
		\item Current: \(\leq 100mA\)
	\end{itemize}
	\item A/V output:
	\begin{itemize}
		\item Connector: HDMI compatible\footnote{It is is also not HDMI\texttrademark{}-certified but should work with any HDMI television.}
		\item Resolution: 640x480, or 320x240 with pixel-doubling
		\item Refresh rate: 60Hz
		\item Aspect ratio: 4:3
		\item Color depth: 16 bits per pixel, RGB565
		\item Audio format: 48KHz 16-bit stereo LPCM
	\end{itemize}
	\item User inputs:
	\begin{itemize}
		\item Connector: 9-pin D-Sub (male) x4
		\item Layout: 8-way directional pad, 6 face buttons, 2 menu buttons
		\item Protocol: Mega-Drive compatible\footnote{Mega-Drive\texttrademark{} is owned by Sega and used without permission. They are unaffiliated with us.}
	\end{itemize}
	\item Game media:
	\begin{itemize}
		\item Connector: SD/MMC card (full-size)
		\item Capacity: 16MBytes to 2TBytes
		\item Format: El-Torito bootable image, platform \Const{0x92}
	\end{itemize}
\end{itemize}

\pagebreak

\subsection{Overview of a Game}

A Neki32 game is quite simple. It is an SD card containing a program to run and possibly other data. Very little is necessary to get code running.

The card is read-only and formatted much like an optical disc.
It contains an El Torito boot record for platform \Const{0x92}.
The El Torito boot record points at the executable file for the game.

The game executable is a flat, 0-mapped binary image of the game's initial memory content.
For example, if the game executable is 3MBytes in size, the system will load it into virtual memory addresses \MemAddr{0} to \MemAddr{3145727}.
The zero page, afterward, is inaccessible. Memory from addres \MemAddr{0} to \MemAddr{4095} always faults.
A small magic number is placed here instead.

The game starts execution at address \MemAddr{4096}, the first accessible address.
All registers are zeroed on entry.
The process starts in ARM mode but may switch to Thumb mode at its choice.

System-calls can be made using a \Instr{svc 0x92} instruction.
The call number is placed in \Reg{r0}, while parameters are placed in \Reg{r1} through \Reg{r5}.
Return values are left in \Reg{r0} after the call is performed.

Exceptions are delivered to the game process as a signal.
Signals are initially blocked. An exception causing a blocked signal will terminate the process.
A signal can be unblocked and handled instead.
In this case, it causes the process to restart to address \MemAddr{4096} with the signal number in \Reg{r0}. A system-call is used to return from the signal.

\section{The boot process}
The boot process treats the game card like an optical disc - it is read-only and organized in naturally-aligned 2048-byte sectors.
Sector \MemAddr{0} contains bytes \MemAddr{0} to \MemAddr{2047}, sector \MemAddr{1} contains bytes \MemAddr{2048} to \MemAddr{4095}, and so on.

\subsection{The beginning of the media}

The system first reads sectors \Const{0x10} and \Const{0x11}.
Sector \Const{0x10} always contains the ISO9660 Primary Volume Descriptor, describing the game media.
The ISO9660 Primary Volume Descriptor gives the name of the media, in a \Const{32}-byte field at offset \Const{40}.
If this is present, not entirely whitespace, and not \Const{CDROM} or \Const{cdrom}, it is taken to be the game's name.

Sector \Const{0x11} always contains the El Torito Boot Volume Descriptor, describing the boot information.
The El Torito Boot Volume Descriptor, from sector \Const{0x11}, is used to locate an El Torito Boot Catalog.
The El Torito Boot Volume Descriptor must contain the magic value \Const{EL TORITO SPECIFICATION} at offset \MemAddr{7}.
It also contains the sector number of the El Torito Boot Catalog, as a 32-bit little-endian number at offset \MemAddr{0x47}.
This is taken to be in units of \Const{2048} bytes, from the beginning of the game media.

\subsection{The boot catalog}
The system reads the El Torito Boot Catalog from the sector number given in the El Torito Boot Volume Descriptor.
Only one sector is read, even though El Torito allows for larger boot catalogs.
The Boot Catalog consists of \Const{32}-byte entries, naturally-aligned.
The first entry must start with the following one-byte magic values:

\begin{tabular}{ r r }
Offset & Value \\
\MemAddr{0x00} & \Const{0x01} \\
\MemAddr{0x1E} & \Const{0x55} \\
\MemAddr{0x1F} & \Const{0xAA}
\end{tabular}

Following this, entries begin with a one-byte value specifying their type, a single byte at offset \MemAddr{0}.

Types \Const{0x01}, \Const{0x90}, or \Const{0x91} begin a section of the Boot Catalog, and contain a Platform ID for entries that follow.
The platform ID is located at offset \MemAddr{1} in such an entry.
The platform ID for a \Neki32 application is \Const{0x92}. A boot entry following this platform will contain game code.
The platform ID for a \Neki32 system-update bundle is \Const{0x22}. A boot entry following this platform will contain packaged system-update data from Nekisoft.

Type \Const{0x88} indicates a bootable entry.
The platform ID of the bootable entry is given in a preceding section entry.
The length of the bootable payload is given as a 2-byte little-endian value at offset \MemAddr{6}. The length is given in units of \Const{512} bytes.
The location of the bootable payload is given as a 4-byte little-endian value at offset \MemAddr{8}. The location is given in units of \Const{2048} bytes, relative to the beginning of the game media.

The first bootable entry of platform ID \Const{0x92} is taken to be the game executable to boot.
The first bootable entry of platform ID \Const{0x22} is taken to be the system update package to examine, if any.
The format of the system update package is not described here.
It should be obtained from Nekisoft and included verbatim.

\subsection{The game executable}

Once the location of the game executable is found in the El Torito Boot Catalog, the system begins to load it.
The game executable is loaded into a new virtual memory space, by itself.
The virtual memory space starts at address \MemAddr{0} and extends to the size specified in the El Torito Boot Catalog.
As the size is given as a 16-bit number in units of \Const{512} bytes, up to 32MBytes could be specified.
However, a game on Neki32 is limited to 24MBytes of memory at any time.

After loading, the zero page is checked for an appropriate magic number.
The first eight bytes should be \Const{NNEARM32}.
The second eight bytes should be the entry point as a 64-bit little-endian value.
This value must always be \MemAddr{0x1000}.

Once the game executable is loaded, the game process starts executing it from \MemAddr{0x1000}, with all registers zeroed.

\subsection{Failures}

If any of these steps encounters a missing magic-number or a failure to read the game media, the booting process stops.
Instead of launching the game, the console will drop to its system menu.
The system menu allows users to see the data saved on their console or turn it off.

\section{Nonvolatile Memory saving}

The Neki32 console includes memory for savegames.
This allows games to be distributed on common SD cards made read-only, without requiring partially-read-only cards.
Each game can save up to 128KBytes of data. The console has space for 30 such savegames, in a region of 4MBytes of NOR Flash.

To use NVM saving, a game must have a valid title set in the Volume ID of its ISO9660 Primary Volume Descriptor.
The title must be nonempty, not all spaces, and not \Const{CDROM} or \Const{cdrom}.
Additionally, the title must not start with a \Const{-} character.
Games that do not use NVM saving should start their Volume ID with a \Const{-} character.

When the system reads a valid name from the Primary Volume Descriptor, it will set up NVM saving before booting the game.
If insufficient space is available, the user will be warned at that time. They can continue anyway or clean up space.
This all happens before launching the game.

Once the game is running, it may assume that NVM saving is available and working.
Generally, once set up, the \VarName{{\Undie}sc{\Undie}nvm{\Undie}save} and \VarName{{\Undie}sc{\Undie}nvm{\Undie}load} calls will not fail.
The game can freely load and store a region of up to 128KBytes.
There is no need to handle no-space-available errors or to prompt the user about making space.

NVM records are protected by SHA256 hashes and double-buffered.
A single free record is always kept for saving the new version of an existing record.
This means that interrupted saves will not corrupt the existing data. The old version will be used until the new version is written entirely.
There is no need for a game to warn the user about interrupting a save.

The first time a game starts, before any data is saved, it is still valid to call \VarName{{\Undie}sc{\Undie}nvm{\Undie}load}.
The savegame will have been created during the boot process.
A newly allocated savegame will contain all \Const{0xFF} bytes.

\section{The instruction set}

The game executable runs in user-mode on an ARMv5TE processor, including both ARM and Thumb modes.
The system will always start executing the game in ARM mode, with the program counter at \MemAddr{0x1000}.
Thumb interworking instructions may be used to transfer into and out of Thumb mode.

No floating-point instructions are available.
Floating-point emulation works well enough to run Quake, at least, if you really want that.

The \Instr{svc 0x92} instruction is used to trigger system-calls. Other \Instr{svc} instructions should not be used.

\pagebreak
\section{System calls}

System-calls are used to access hardware features in a backward- and forward-compatible way.
The system-call interface for Neki32 comprises 21 different calls.

To run a system call, first place its inputs in CPU registers. The call number is passed in register \Reg{r0}.
Parameters, if any, are passed in registers \Reg{r1} to \Reg{r5}. Then, use the \Instr{svc 0x92} instruction.
The kernel will perform the requested operation.
The return value is stored in \Reg{r0} after the call finishes.

Typically, system-calls will return a negative error number if they fail, or a nonnegative value on success.
They may read or write in the memory of the caller.

System-calls are nonblocking. If a long-term operation is started, its system-call returns with \Const{-{\Undie}SC{\Undie}EAGAIN}.
The call can be repeated until it completes, returning a successful result.
In the mean time, the \Const{{\Undie}sc{\Undie}pause} system-call can be used to block the caller.
For example, the following code would wait for any input events:
\begin{lstlisting}[language=C]
_sc_input_t mybuf[8] = {0};
while(_sc_input(mybuf, sizeof(mybuf[0]), sizeof(mybuf)) == -_SC_EAGAIN)
{
	_sc_pause();
}
\end{lstlisting}

\subsection{Basics}

These system-calls relate to the general usage of the system-call interface.

\SysCall{none}{0x00}
{
	Does nothing. This enters and exits the kernel as usual but does nothing else.
}
{
	\SysParmNone
	\SysRetnNone
}

\SysCall{pause}{0x01}
{
	Waits until any event happens to the calling process, or has happened since this call was last made.
	
	If an event has already occurred, the call returns immediately.
	If no event has occurred, the calling process will not be scheduled again until it does.
	This is the only way to actually block a process at the kernel level.
	
	In this context, "any event" refers to the completion or failure of a prior system-call which returned \Const{-{\Undie}SC{\Undie}EAGAIN}.
}
{
	\SysParmNone
	\SysRetnNone
}

\SysCall{print}{0xB0}
{
	Prints output to the text-mode screen.
	Prints the sequence of bytes at buf{\Undie}ptr of length buf{\Undie}len bytes.
	Currently supports very few control sequences.
	Basically only used for debugging.
	Returns the number of bytes printed.
	Note - does NOT stop at NULs!
}
{
	\SysParm{r1}{const char*}{buf{\Undie}ptr}{Location of data to print.}
	\SysParm{r2}{int}{buf{\Undie}len}{Number of bytes to print.}
	\SysRetn{int}{The number of bytes printed, or a negative error number.}
}	

\subsection{Game input/output}

These system-calls relate to the user's gamepads and television.
No setup or configuration is necessary to use these system-calls.
Each program starts with the audio-visual and input peripherals ready to use.

\SysCall{getticks}{0x02}
{
	Returns the number of milliseconds since the system was booted. Does not fail.	
}
{
	\SysParmNone
	\SysRetn{int}{The number of milliseconds elapsed since boot.}
}


\SysCall{gfx{\Undie}flip}{0x30}
{
	Enqueues a change of the video front-buffer.
	The given buffer will become the front-buffer at the next vertical-blanking interval.
	
	If the given mode is 0, text-mode will be displayed, and buffer must be given as NULL.
	If the given mode is nonzero, a valid buffer must be specified, and large enough for one full-screen image.
	
	Returns the address of the buffer currently displayed. 
	The return value may be 0 if the current front-buffer belongs to another process.
	This call may occasionally take effect immediately, and return its buffer parameter, if the call is made just before vertical blanking.
	\\
	The following mode values are allowed:\\
	\begin{tabular}{l l l}
	Mode & Number & Description \\
	\Const{{\Undie}SC{\Undie}GFX{\Undie}MODE{\Undie}TEXT}          & 0 & No framebuffer; kernel text mode only \\
	\Const{{\Undie}SC{\Undie}GFX{\Undie}MODE{\Undie}VGA{\Undie}16BPP}     & 1 & 640x480@60Hz RGB565, 1280 bytes/line \\ 
	\Const{{\Undie}SC{\Undie}GFX{\Undie}MODE{\Undie}320X240{\Undie}16BPP} & 2 & 320x240@60Hz RGB565, 640 bytes/line
	\end{tabular}
}
{
	\SysParm{r1}{int}{mode}{The video mode in which to display the new buffer.}
	\SysParm{r2}{const void *}{buffer}{The location of the buffer in memory to display.}
	\SysRetn{int}{The currently-displayed image buffer, or a negative error number.}
}

\SysCall{snd{\Undie}play}{0x60}
{
	Enqueues audio samples for playback.
	Samples are read from the given buffer and copied into the kernel for playback.
	Either the whole buffer is consumed or none is.
	The caller may specify the maximum amount of audio to buffer in the kernel.
	This allows trading latency for stability.
	Returns 0 on success, or a negative error number.
	
	The following mode values are allowed:\\
	\begin{tabular}{l l l}
	Mode & Number & Description \\
	\Const{{\Undie}SC{\Undie}SND{\Undie}MODE{\Undie}SILENT}&0 &Stops all sounds \\
	\Const{{\Undie}SC{\Undie}SND{\Undie}MODE{\Undie}48K{\Undie}16B{\Undie}2C}&1 &LPCM, 48KHz, 16b left-then-right, native endian \\
	\end{tabular}
}
{
	\SysParm{r1}{int}{mode}{The audio format of the data in the buffer.}
	\SysParm{r2}{const void *}{chunk}{The location of the buffer in memory to enqueue.}
	\SysParm{r3}{int}{chunkbytes}{The number of bytes in the buffer to enqueue.}
	\SysParm{r4}{int}{maxbuf}{The maximum number of bytes to enqueue in the kernel.}
	\SysRetn{int}{0 on success, or a negative error number.}
}

\SysCall{input}{0x50}
{
	Reads input events from the system into the given buffer.
	Returns how many events were filled in the buffer, or a negative error number.
	
	The first byte of any event is a character indicating its type. Presently, only the following are defined:
	
	\begin{tabular}{l l l}
	First byte & Total bytes & Event type \\
	\Const{'A'} (\Const{0x41}) & 4 & Player 1 digital gamepad input \\
	\Const{'B'} (\Const{0x42}) & 4 & Player 2 digital gamepad input \\
	\Const{'C'} (\Const{0x43}) & 4 & Player 3 digital gamepad input \\
	\Const{'D'} (\Const{0x44}) & 4 & Player 4 digital gamepad input
	\end{tabular}	
	\\
	The input events defined currently follow the format below:
	
	\begin{tabular}{l l l}
	Offset & Size & Field \\
	0 & 1 & Type \\
	1 & 1 & Unused \\
	2 & 2 & Buttons Pressed
	\end{tabular}
	\\
	The "buttons pressed" field is a bitmask where a 1-bit is a pressed button and a 0-bit is a released button.
	The buttons use the following indexes:
	
	\begin{tabular}{l l l}
	Button & Index & Bitmask \\
	Up     &  \Const{0}    & \Const{0x0001} \\
	Left   &  \Const{1}    & \Const{0x0002} \\
	Down   &  \Const{2}    & \Const{0x0004} \\
	Right  &  \Const{3}    & \Const{0x0008} \\
	A      &  \Const{4}    & \Const{0x0010} \\
	B      &  \Const{5}    & \Const{0x0020} \\
	C      &  \Const{6}    & \Const{0x0040} \\
	X      &  \Const{7}    & \Const{0x0080} \\
	Y      &  \Const{8}    & \Const{0x0100} \\
	Z      &  \Const{9}    & \Const{0x0200} \\ 
	Start  & \Const{10}    & \Const{0x0400} \\
	Mode   & \Const{11}    & \Const{0x0800} \\ 
	\end{tabular}
	\\
	This system-call will typically return an input event per frame per controller port. The buffer should be at least 4-byte-aligned.
}
{
	\SysParm{r1}{{\Undie}sc{\Undie}input{\Undie}t *}{buffer{\Undie}ptr}{The location of the buffer to store the input events.}
	\SysParm{r2}{int}{bytes{\Undie}per{\Undie}event}{The number of bytes in each element of the buffer.}
	\SysParm{r3}{int}{bytes{\Undie}max}{The total size of the buffer in bytes.}
	\SysRetn{int}{The number of events filled or a negative error number.}
}

\subsection{Data access}

\SysCall{disk{\Undie}read2k}{0x91}
{
	Reads a 2048-byte sector from the disk into the given buffer.
	The sector number is given in units of 2KByte, i.e. not a byte-offset.
	Returns the number of bytes read (2048) on success or a negative error number.
	May return \Const{-{\Undie}SC{\Undie}EAGAIN} if the operation has started and will finish later.
}
{
	\SysParm{r1}{int}{sector{\Undie}num}{Which sector to load from the disk, in units of 2048 bytes.}
	\SysParm{r2}{void *}{buf2k}{The location in memory to store the data being read.}
	\SysRetn{int}{The number of bytes read, 2048, on success, or a negative error number.}
}

\SysCall{disk{\Undie}write2k}{0x92}
{
	Writes a 2048-byte sector to the disk from the given buffer.
	The sector number is given in units of 2KByte, i.e. not a byte-offset.
	Returns the number of bytes written (2048) on success or a negative error number.
	May return \Const{-{\Undie}SC{\Undie}EAGAIN} if the operation has started and will finish later.
}
{
	\SysParm{r1}{int}{sector{\Undie}num}{Which sector to write on the disk, in units of 2048 bytes.}
	\SysParm{r2}{const void *}{buf2k}{The data in memory to store onto the disk.}
	\SysRetn{int}{The number of bytes written, 2048, on success, or a negative error number.}
}

\SysCall{nvm{\Undie}save}{0x81}
{
	Writes data to the configured nonvolatile memory record, overwriting any previous data.
	The contents should be in the buffer at "data", of length "len".
	Writes are atomic and update the whole record each time. No partial writes are possible.
	Returns the number of bytes written on success or a negative error number.
}
{
	\SysParm{r1}{const void *}{data}{The data in memory to store to nonvolatile memory.}
	\SysParm{r2}{int}{len}{How many bytes to store.}
	\SysRetn{int}{The number of bytes written or a negative error number.}
}

\SysCall{nvm{\Undie}load}{0x82}
{
	Reads from the configured nonvolatile memory record into the given buffer.
	The buffer to place the results in is at "buf", of length "len".
	Reads are protected by SHA256; corruption will result in the file being lost (\Const{-{\Undie}SC{\Undie}ENOENT}).
	Returns the number of bytes read on success or a negative error number.
}
{
	\SysParm{r1}{void *}{buf}{The location in memory to put the data from nonvolatile memory.}
	\SysParm{r2}{int}{len}{How many bytes to load.}
	\SysRetn{int}{The number of bytes read or a negative error number.}
}

\subsection{Process setup}

\SysCall{mem{\Undie}sbrk}{0x40}
{
	Changes the size of the calling process's memory space, adding "req" new bytes.
	(The memory space cannot ever be reduced, except by calling exec() with a smaller image.)
	The new bytes are appended at the old end-of-process address. The OLD end-of-process is returned.
	A negative error number is returned on failure (probably, \Const{-{\Undie}SC{\Undie}ENOMEM}).
}
{
	\SysParm{r1}{int}{req}{The number of bytes to add to the process memory space.}
	\SysRetn{int}{The previous size of the process, before adding the new bytes. Or, a negative error number.}
}

\SysCall{sig{\Undie}mask}{0x20}
{
	Alters the signal mask of the calling thread.
	Returns the \emph{old} mask.
	The following signal numbers are used by the kernel:
	
	\begin{tabular}{l l l}
	Signal Name & Number & Description \\
	\Const{{\Undie}SC{\Undie}SIGILL} &4 & Illegal operation, i.e. bad opcode\\
	\Const{{\Undie}SC{\Undie}SIGTRAP} &5 & Debug trap requested\\
	\Const{{\Undie}SC{\Undie}SIGKILL} &9 & Killed (cannot be blocked)\\
	\Const{{\Undie}SC{\Undie}SIGSEGV} &11 & Segmentation violation, i.e. out-of-bounds memory access\\
	\Const{{\Undie}SC{\Undie}SIGPIPE} &13 & Pipe broken when writing to kernel-level file\\
	\Const{{\Undie}SC{\Undie}SIGCHLD} &20 & Child process changed state (not applicable to game processes)
	\end{tabular}
	\\
	The signal mask can be altered in the following ways:
	
	\begin{tabular}{l l l}
	Operation & Value & Description\\
	\Const{{\Undie}SC{\Undie}SIGMASK{\Undie}BLOCK} & 0 & Blocks signals where the input bit is ``1".\\
	\Const{{\Undie}SC{\Undie}SIGMASK{\Undie}UNBLOCK} & 1 & Unblocks signals where the input bit is ``1".\\
	\Const{{\Undie}SC{\Undie}SIGMASK{\Undie}SETMASK} & 2 & Blocks signals if the input is ``1" and unblocks all others.
	\end{tabular}
}
{
	\SysParm{r1}{int}{how}{Which operation to perform on the signal mask.}
	\SysParm{r2}{int}{bits}{The input bitmask for the given operation.}
	\SysRetn{int}{The old signal mask, before the successful operation. Or a negative error number on failure.}
}

\SysCall{sig{\Undie}return}{0x22}
{
	Returns from a signal handler.
	
	The kernel saves the context that is interrupted when a signal is taken.
	It then masks all signals and restarts the process to address \MemAddr{4096}.
	This system-call returns to the interrupted context, including the old signal mask.
	
	As the kernel only saves a single context, signals are not reentrant.
	You probably do not want to unmask signals from inside a running signal handler.
}
{
	\SysParmNone
	\SysRetnDead
}

\SysCall{env{\Undie}save}{0x08}
{
	Appends the given data to the kernel's argument/environment buffer for the calling process.
	Subsequent calls append to the buffer; call with buf=len=0 to reset the buffer.
	This buffer is preserved across calls to exec() and mexec{\Undie}apply().
	Conventionally it should contain a series of NUL-terminated argument strings,
	then an extra NUL, then a series of NUL-terminated environment strings.
	Returns the number of bytes written or a negative error number.
}
{
	\SysParm{r1}{const void *}{buf}{The data in memory to store to the environment buffer.}
	\SysParm{r2}{int}{len}{How many bytes to store.}
	\SysRetn{int}{The number of bytes written or a negative error number.}	
}

\SysCall{env{\Undie}load}{0x09}
{
	Reads from the kernel's argument/environment buffer for the calling process.
	Writes the result into the calling process's user memory, usually after an exec() or mexec{\Undie}apply().
	Unlike {\Undie}sc{\Undie}env{\Undie}save, starts from the beginning each time it's called.
	Returns the number of bytes copied or a negative error number.
}
{
	\SysParm{r1}{void *}{buf}{The location in memory to put the data from the environment buffer.}
	\SysParm{r2}{int}{len}{How many bytes to load.}
	\SysRetn{int}{The number of bytes read or a negative error number.}
}

\SysCall{mexec{\Undie}append}{0xA1}
{
	Appends the given data to the kernel's pending memory image for the calling process.
	Subsequent calls append to the buffer; call with buf=len=0 to reset the buffer.
	The first 4KBytes appended are always inaccessible afterwards and can contain anything.
	The memory at address \MemAddr{0x1000} (+4KBytes in) is where execution starts after {\Undie}sc{\Undie}mexec{\Undie}apply.
	Returns the number of bytes appended on success.
	Returns a negative error number if a failure occurs before any bytes were appended.
}
{
	\SysParm{r1}{const void *}{buf}{The data in memory to append to the new memory space.}
	\SysParm{r2}{int}{len}{How many bytes to append.}
	\SysRetn{int}{The number of bytes appended or a negative error number.}	
}

\SysCall{mexec{\Undie}apply}{0xA2}
{
	Concludes an in-memory exec and replaces the current with the pending image.
	Does not return and does not fail.
	If there is no pending image, the caller exits as though killed by {\Undie}SC{\Undie}SIGSEGV.
}
{
	\SysParmNone
	\SysRetnDead
}

\SysCall{exit}{0x07}
{
	Generally obliterates the calling process.
	Optionally reports a signal that was responsible for its demise.
}
{
	\SysParm{r1}{int}{exitcode}{The return value to report to the parent process.}
	\SysParm{r2}{int}{signal}{The signal number responsible for the exit, if any. Zero otherwise.}
	\SysRetnDead
}

\pagebreak

\subsection{Error codes}
The following error codes may be returned by the kernel.
These values are defined as positive integers here.
When returned by a system-call, they are usually negated.
For example, a system-call which fails because there is not enough memory might then return -12.
\\
\\
\begin{tabular}{l l l}
\textbf{Error} & \textbf{Number} & \textbf{Description} \\
\Const{{\Undie}SC{\Undie}EPERM}       &  1 & Operation not permitted. \\
\Const{{\Undie}SC{\Undie}ENOENT}      &  2 & No such file or directory. \\
\Const{{\Undie}SC{\Undie}ESRCH}       &  3 & No such process. \\
\Const{{\Undie}SC{\Undie}EIO}         &  5 & I/O error. \\
\Const{{\Undie}SC{\Undie}ENXIO}       &  6 & No such device or address. \\
\Const{{\Undie}SC{\Undie}E2BIG}       &  7 & Argument list too long. \\
\Const{{\Undie}SC{\Undie}ENOEXEC}     &  8 & Executable file format error. \\
\Const{{\Undie}SC{\Undie}EBADF}       &  9 & Bad file descriptor. \\
\Const{{\Undie}SC{\Undie}ECHILD}      & 10 & No child processes. \\
\Const{{\Undie}SC{\Undie}EAGAIN}      & 11 & Resource unavailable, try again. \\
\Const{{\Undie}SC{\Undie}ENOMEM}      & 12 & Not enough space. \\
\Const{{\Undie}SC{\Undie}EFAULT}      & 14 & Bad address. \\
\Const{{\Undie}SC{\Undie}EBUSY}       & 16 & Device or resource busy. \\
\Const{{\Undie}SC{\Undie}EEXIST}      & 17 & File exists. \\
\Const{{\Undie}SC{\Undie}ENOTDIR}     & 20 & Not a directory or a symbolic link to a directory. \\
\Const{{\Undie}SC{\Undie}EISDIR}      & 21 & Is a directory. \\
\Const{{\Undie}SC{\Undie}EINVAL}      & 22 & Invalid argument. \\
\Const{{\Undie}SC{\Undie}ENFILE}      & 23 & Too many files open in system. \\
\Const{{\Undie}SC{\Undie}EMFILE}      & 24 & File descriptor value too large. \\
\Const{{\Undie}SC{\Undie}ENOTTY}      & 25 & Inappropriate I/O control operation. \\
\Const{{\Undie}SC{\Undie}EFBIG}       & 27 & File too large. \\
\Const{{\Undie}SC{\Undie}ENOSPC}      & 28 & No space left on device. \\
\Const{{\Undie}SC{\Undie}ESPIPE}      & 29 & Invalid seek. \\
\Const{{\Undie}SC{\Undie}EPIPE}       & 32 & Broken pipe. \\
\Const{{\Undie}SC{\Undie}EDEADLOCK}   & 35 & Resource deadlock would occur. \\
\Const{{\Undie}SC{\Undie}ENAMETOOLONG}& 36 & Filename too long. \\
\Const{{\Undie}SC{\Undie}ENOSYS}      & 38 & Functionality not supported. \\
\Const{{\Undie}SC{\Undie}ENOTEMPTY}   & 39 & Directory not empty. \\
\Const{{\Undie}SC{\Undie}ELOOP}       & 40 & Too many levels of symbolic links. \\
\end{tabular}

\subsection{System calls by number}
The following table lists all system-calls usable by a game, sorted by call number.
\\
\\
\begin{tabular}{l l}
Number & Name\\
\Const{0x00} &\VarName{{\Undie}sc{\Undie}none}\\
\Const{0x01} &\VarName{{\Undie}sc{\Undie}pause}\\
\Const{0x02} &\VarName{{\Undie}sc{\Undie}getticks}\\
\Const{0x07} &\VarName{{\Undie}sc{\Undie}exit}\\
\Const{0x08} &\VarName{{\Undie}sc{\Undie}env{\Undie}save}\\
\Const{0x09} &\VarName{{\Undie}sc{\Undie}env{\Undie}load}\\
\Const{0x20} &\VarName{{\Undie}sc{\Undie}sig{\Undie}mask}\\
\Const{0x22} &\VarName{{\Undie}sc{\Undie}sig{\Undie}return}\\
\Const{0x30} &\VarName{{\Undie}sc{\Undie}gfx{\Undie}flip}\\
\Const{0x40} &\VarName{{\Undie}sc{\Undie}mem{\Undie}sbrk}\\
\Const{0x50} &\VarName{{\Undie}sc{\Undie}input}\\
\Const{0x60} &\VarName{{\Undie}sc{\Undie}snd{\Undie}play}\\
\Const{0x81} &\VarName{{\Undie}sc{\Undie}nvm{\Undie}save}\\
\Const{0x82} &\VarName{{\Undie}sc{\Undie}nvm{\Undie}load}\\
\Const{0x91} &\VarName{{\Undie}sc{\Undie}disk{\Undie}read2k}\\
\Const{0x92} &\VarName{{\Undie}sc{\Undie}disk{\Undie}write2k}\\
\Const{0xA1} &\VarName{{\Undie}sc{\Undie}mexec{\Undie}append}\\
\Const{0xA2} &\VarName{{\Undie}sc{\Undie}mexec{\Undie}apply}\\
\Const{0xB0} &\VarName{{\Undie}sc{\Undie}print}\\
\end{tabular}

\section{The C SDK}
The C SDK is an easy way to start writing programs for Neki32.
It provides a runtime environment that behaves like a POSIX-compatible system, such as Linux or FreeBSD.
The SDK includes the following parts.
\subsection{SDK Contents}
\subsubsection{Compiler Wrappers}
The compiler wrappers help to invoke GCC or LLVM with the right options for building a Neki32 executable.
You must have an appropriate GCC or LLVM compiler installed, of course. It needs to be able to target the ARMv5TE architecture.
\subsubsection{C Runtime}
The C Runtime is what initially starts running when the Neki32 kernel loads your program.
It requests memory for all your variables, unmasks signals, and calls your main function.
It also contains the linker configuration, so the linker can make an executable in the right format (a flat 0-based binary).
\subsubsection{Picolibc}
This is a port of PicoLibC to the Neki32. PicoLibC is a portable C Standard Library. It provides functions like printf and strcpy.
\subsubsection{PVMK OS library}
The OS Library is a link between the PicoLibC code and the system-calls available on the Neki32.
It handles some things that aren't implemented in the kernel itself.

For example, the system-call interface on Neki32 provides block-level access to sectors from the game card.
The system doesn't care what kind of filesystem is on the card.
So, when your application calls fopen(), someone has to go understand the filesystem on the card and find the file you wanted.
The code is in this library, so you can open/read/close like normal.
\subsubsection{Updates Package}
This is the official Neki32 system-update package from Nekisoft.
This can be included on game media to ensure that players have the latest system software.
Note that a license is required to distribute this - you must adhere to our software quality and marketing guidelines.
See the licensing section for more information.
\subsubsection{SDL System-Call Shims}
This is an implementation of some system-calls on top of the SDL2 library.
Using this, instead of the real system-call library, you can build and test your code on a desktop Linux machine.
Then, you could compile the same application for Neki32 with minimal changes.

\section{Examples}
\subsection{Just Assembly}
It is possible to make a bootable Neki32 game card using only an ARM assembler. The executable code can be written in assembly, of course.
The same assembly can be used to make ISO9660 and El Torito structures, referencing the executable code.
For simplicity, we can place the executable at the beginning of the disk image.
Then, a byte location in the disk, the executable, and the process memory are all the same.

Source code for this example is found in \PathName{examples/allasm} in the SDK.

\subsection{Assembly and some Data}
A program running on the Neki32 can load more data off the game card. The system-call \VarName{{\Undie}sc{\Undie}disk{\Undie}read2k} is used to perform this operation.
The previous example can be extended to load more data off the game card, after the boot program is already running.

Source code for this example is found in \PathName{examples/asmdata} in the SDK.

\subsection{Assembly in a Filesystem}
\subsection{Adding some Freestanding C}
\subsection{Using the C SDK Instead}

\section{Common errors}
This section contains examples of why a program may not work as expected. 
\subsection{System call failures}
Most system-calls in PVMK will always complete predictably if given valid parameters.
Unexpected failures are rare due to the restricted nature of the environment.
An enumeration of system-calls and potential failures follows.
\\

\subsubsection{\Const{0x00} \VarName{{\Undie}sc{\Undie}none}}
\BL This call cannot fail.
\BL In some sense, it also cannot succeed.

\subsubsection{\Const{0x01} \VarName{{\Undie}sc{\Undie}pause}}
\BL This call cannot fail.
\BL Note that this call may return spuriously for a number of reasons. A previous system-call may have triggered an unpause which has been ignored. Or, the timing of a following system-call may not be predictable.
\BL To block waiting on a system-call result, retry the call, and use \VarName{{\Undie}sc{\Undie}pause} in a loop. Call pause if and only if an \Const{-{\Undie}SC{\Undie}EAGAIN} result is returned from the call in question.

\subsubsection{\Const{0x02} \VarName{{\Undie}sc{\Undie}getticks}}
\BL This call cannot fail. 
\BL Note that this returns ticks since the system booted, not since the program began executing. 
\BL When using the debugger, this may also show discontinuities. 
\BL The units are milliseconds. As the value is 32-bit, the tick count may overflow if the user leaves the console running for 25 days. Games do not need to handle this, but may choose to handle the overflow or to crash.

\subsubsection{\Const{0x07} \VarName{{\Undie}sc{\Undie}exit}}
\BL This call cannot fail. 
\BL The system may try to re-launch a game that exits, up to 3 times.

\subsubsection{\Const{0x08} \VarName{{\Undie}sc{\Undie}env{\Undie}save}}
\BL This call can fail if the buffer is not in valid memory. 
\BL This call can fail if the environment buffer is already full. 
\BL This call can fail if the pointer is NULL but the length is nonzero. 
\BL This call can fail if the length is zero but the pointer is non-NULL. 
\BL This call can fail if the length is too large for the environment at all. 
\BL Note that subsequent calls append to the buffer, not starting again. 

\subsubsection{\Const{0x09} \VarName{{\Undie}sc{\Undie}env{\Undie}load}}
\BL This call can fail if no data is in the environment buffer already. 
\BL This call can fail if the buffer is not in valid memory. 
\BL This call can fail if the given buffer is too small for the environment stored. 
\BL Note that subsequent calls do not continue reading from the buffer, instead starting again. 

\subsubsection{\Const{0x20} \VarName{{\Undie}sc{\Undie}sig{\Undie}mask}}
\BL This call can fail if the ``how" parameter is invalid. 
\BL This call can cause a signal to be taken immediately when unmasked, if it was already pending. 

\subsubsection{\Const{0x22} \VarName{{\Undie}sc{\Undie}sig{\Undie}return}}
\BL This call only restores a single saved context. 
\BL This call will certainly misbehave if called before a signal is handled, or called twice for one signal. 
\BL Enabling signals again in a signal handler may cause the old saved context to be lost. 

\subsubsection{\Const{0x30} \VarName{{\Undie}sc{\Undie}gfx{\Undie}flip}}
\BL This call can fail if an invalid buffer pointer is given. 
\BL This call can fail if an invalid mode value is given. 
\BL This call can fail if the mode is ``text" mode (0) but the buffer is non-NULL. 
\BL This call can fail if the mode is not ``text" (nonzero) but the buffer is NULL. 
\BL This call can occasionally return the buffer it was given, immediately. This happens if the call is made just as the system enters vertical blanking. 
\BL This call can return 0 if the currently-displayed buffer belongs to another process. 

\subsubsection{\Const{0x40} \VarName{{\Undie}sc{\Undie}mem{\Undie}sbrk}}
\BL This call can fail if the system is out of memory. 
\BL This call can fail if the amount of memory requested is zero or negative. 

\subsubsection{\Const{0x50} \VarName{{\Undie}sc{\Undie}input}}
\BL This call can fail if the buffer is not in valid memory. 
\BL This call can fail if the buffer sizes are zero or negative. 
\BL This call can fail if the buffer size overall is not a multiple of the buffer element size. 

\subsubsection{\Const{0x60} \VarName{{\Undie}sc{\Undie}snd{\Undie}play}}
\BL This call can fail if the chunk size is too large for the kernel to buffer at all. 
\BL This call can fail if the maximum buffered size is set too low. 
\BL This call can fail if the buffer is not in valid memory. 
\BL This call can fail if the mode given is invalid. The only valid mode currently is 1. 

\subsubsection{\Const{0x81} \VarName{{\Undie}sc{\Undie}nvm{\Undie}save}}
\BL This call can fail if the user chose not to make space for the game to save. A game does not need to handle this case.
\BL This call can fail if the buffer pointer and length do not refer to valid memory. 
\BL This call can fail if the buffer is oversized. 
\BL This call can fail if the game did not provide a valid name in its ISO9660 Primary Volume Descriptor, to identify the NVM record. 

\subsubsection{\Const{0x82} \VarName{{\Undie}sc{\Undie}nvm{\Undie}load}}
\BL This call can return a buffer full of 0xFF or 0x00 if the save record was just created. 
\BL This call can fail for the same reasons as \VarName{{\Undie}sc{\Undie}nvm{\Undie}save}. 

\subsubsection{\Const{0x91} \VarName{{\Undie}sc{\Undie}disk{\Undie}read2k}}
\BL This call can fail if the sector number is invalid. 
\BL This call can fail if the buffer is not in valid memory. 

\subsubsection{\Const{0x92} \VarName{{\Undie}sc{\Undie}disk{\Undie}write2k}}
\BL This call can fail if the sector number is invalid.
\BL This call can fail if the buffer is not in valid memory.
\BL This call can fail if the card is write-protected. 

\subsubsection{\Const{0xA1} \VarName{{\Undie}sc{\Undie}mexec{\Undie}append}}
\BL This call can fail if the pending memory image is already too large. 
\BL This call can fail if the given buffer is not in valid memory. 
\BL This call can fail if the given buffer is too large for the pending memory image. 
\BL This call can fail if the buffer pointer is NULL but the length is nonzero. 
\BL This call can fail if the buffer length is zero but the pointer is non-NULL. 

\subsubsection{\Const{0xA2} \VarName{{\Undie}sc{\Undie}mexec{\Undie}apply}}
\BL This call cannot fail. 
\BL If the pending memory image is not valid, the process will die from a segfault. 

\subsubsection{\Const{0xB0} \VarName{{\Undie}sc{\Undie}print}}
\BL This call can fail if the buffer is not in valid memory. 
\BL This call can fail if the length is invalid. 
\BL This call may perform unexpectedly as it does not stop at NULs in the given buffer. 



\end{document}